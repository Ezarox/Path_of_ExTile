const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const GRID_SIZE = 21;
const CELL_SIZE = 30;
const GRID_OFFSET_Y = CELL_SIZE;
const VIEW_WIDTH = GRID_SIZE * CELL_SIZE;
const VIEW_BORDER = CELL_SIZE;
const VIEW_HEIGHT = (GRID_SIZE + 2) * CELL_SIZE;
const VIEW_RENDER_WIDTH = VIEW_WIDTH + VIEW_BORDER * 2;
const VIEW_GAP = 0;
const CANVAS_WIDTH = VIEW_RENDER_WIDTH * 2 + VIEW_GAP;
const CANVAS_HEIGHT = VIEW_HEIGHT;
const BUILD_DURATION = 60 * 1000; // ms
const NPC_SPEED = 3;
const NPC_RADIUS = 0.35;
const PAD_PULSE_PERIOD = 3.5;
const ENTRANCE_X = Math.floor(GRID_SIZE / 2);
const FIXED_TIMESTEP = 1 / 120;
const MAX_FRAME_DELTA = 0.1;

const CELL_EMPTY = 0;
const CELL_STATIC = 1;
const CELL_PLAYER = 2;
const CELL_SPEED = 3;
const CELL_SLOW = 4;
const CELL_SPEED_USED = 5;
const CELL_SLOW_USED = 6;
const CELL_SPECIAL = 7;
const CELL_DETOUR = 8;
const CELL_STONE = 9;
const CELL_REWIND = 10;
const CELL_DETOUR_USED = 11;
const CELL_STONE_USED = 12;
const CELL_REWIND_USED = 13;
const CELL_SINGLE = 14;
const CELL_STATIC_SPECIAL = 15;

const SPECIAL_TYPES = ["radius", "row", "column", "gravity", "lightning"];
const SPECIAL_RADIUS = 4;
const SPECIAL_LINGER = 3;
const FREEZING_BUILDUP = 10;
const SPECIAL_SLOW_MULT = 0.7;
const FREEZING_MIN_MULT = 0.3;
const LIGHTNING_STUN = 1.5;
const LIGHTNING_COOLDOWN = 3;
const PANEL_SLOW_MULT = 0.55;
const PANEL_FAST_MULT = 1.5;
const MEDUSA_SLOW_MULT = 0.3;
const PANEL_EFFECT_DURATION = 5;
const GRAVITY_MIN_MULT = 0.4;
const GRAVITY_MAX_MULT = 0.7;
const PAD_AI_SCORES = {
  speed: -3,
  slow: 3,
  detour: 4,
  stone: 3,
  rewind: 8
};
const SPECIAL_RADIUS_WEIGHT = 1.5;
const SPECIAL_BEAM_WEIGHT = 1.2;
const SPECIAL_GRAVITY_WEIGHT = 0.9;
const SPECIAL_LIGHTNING_WEIGHT = 2.5;
const AI_PATH_WEIGHT = 12;
const BUILD_MODE_ORDER = ["normal", "single", "special"];

const MOVES = [
  { dx: 1, dy: 0, cost: 1, diagonal: false },
  { dx: -1, dy: 0, cost: 1, diagonal: false },
  { dx: 0, dy: 1, cost: 1, diagonal: false },
  { dx: 0, dy: -1, cost: 1, diagonal: false },
  { dx: 1, dy: 1, cost: Math.SQRT2, diagonal: true },
  { dx: -1, dy: 1, cost: Math.SQRT2, diagonal: true },
  { dx: 1, dy: -1, cost: Math.SQRT2, diagonal: true },
  { dx: -1, dy: -1, cost: Math.SQRT2, diagonal: true }
];

const PAD_VISUALS = {
  speed: {
    color: { r: 255, g: 110, b: 110 },
    idleAlpha: 0.28,
    activeAlpha: 0.62,
    baseBrightness: 0.46,
    pulseRange: 0.32,
    iconChar: "»",
    charOffset: { x: 0, y: -0.60 },
    charScale: 0.95
  },
  slow: {
    color: { r: 120, g: 170, b: 255 },
    idleAlpha: 0.3,
    activeAlpha: 0.64,
    baseBrightness: 0.48,
    pulseRange: 0.3,
    iconChar: "≈",
    charOffset: { x: 0, y: 0.6 }
  },
  detour: {
    color: { r: 70, g: 210, b: 205 },
    idleAlpha: 0.24,
    activeAlpha: 0.55,
    baseBrightness: 0.55,
    pulseRange: 0.22,
    iconChar: "↶",
    charOffset: { x: -0.4, y: 1.8 },
    charScale: 0.83
  },
  stone: {
    color: { r: 185, g: 180, b: 168 },
    idleAlpha: 0.28,
    activeAlpha: 0.54,
    baseBrightness: 0.45,
    pulseRange: 0.18,
    iconChar: "◈",
    charOffset: { x: -0.4, y: 1 }
  },
  rewind: {
    color: { r: 255, g: 210, b: 140 },
    idleAlpha: 0.26,
    activeAlpha: 0.6,
    baseBrightness: 0.52,
    pulseRange: 0.2,
    iconChar: "↺",
    charOffset: { x: -0.4, y: 0.5 },
    charScale: 0.75
  }
};

const CATALOGUE_ITEMS = [
  {
    id: "start",
    icon: "gate-start",
    name: "Start Gate (S)",
    description: "Runner spawns here and must climb straight into the maze before steering."
  },
  {
    id: "finish",
    icon: "gate-finish",
    name: "Finish Gate (F)",
    description: "Timer stops only when the runner reaches this exit."
  },
  {
    id: "seedWall",
    icon: "wall-static",
    name: "Seed Wall",
    description: "Immovable 2×2 block generated by the seed. Neither player nor AI can refund it."
  },
  {
    id: "playerWall",
    icon: "wall-player",
    name: "Wall (2×2)",
    description: "Costs 1 wall from your pool. Blocks a 2×2 area and can be refunded during build."
  },
  {
    id: "single",
    icon: "wall-single",
    name: "Single Block (1×1)",
    description: "Costs 1 single. Perfect for fine tuning choke points."
  },
  {
    id: "speedPad",
    icon: "pad-speed",
    name: "Speed Pad",
    description: () => `Boosts runner speed to ${formatMultiplier(PANEL_FAST_MULT)} for ${PANEL_EFFECT_DURATION}s.`
  },
  {
    id: "slowPad",
    icon: "pad-slow",
    name: "Slow Pad",
    description: () => `Drops speed to ${formatMultiplier(PANEL_SLOW_MULT)} for ${PANEL_EFFECT_DURATION}s.`
  },
  {
    id: "detourPad",
    icon: "pad-detour",
    name: "Detour Pad",
    description: "Reverses the runner along its current heading until a wall or boundary is reached, then reroutes."
  },
  {
    id: "stonePad",
    icon: "pad-stone",
    name: "Stone Pad",
    description: () => `Medusa effect: locks speed to ${formatMultiplier(MEDUSA_SLOW_MULT)} until the runner changes direction.`
  },
  {
    id: "rewindPad",
    icon: "pad-rewind",
    name: "Rewind Pad",
    description: "Teleports the runner to the start gate and forces a full re-path."
  },
  {
    id: "freeze",
    icon: "special-freeze",
    name: "Freezing Field",
    description: () =>
      `Slows inside the aura from ${formatMultiplier(SPECIAL_SLOW_MULT)} down to ${formatMultiplier(
        FREEZING_MIN_MULT
      )} over ${FREEZING_BUILDUP}s. Leaving restores speed over ${SPECIAL_LINGER}s.`
  },
  {
    id: "beamRow",
    icon: "special-row",
    name: "Horizontal Slow Beam",
    description: () =>
      `Applies ${formatMultiplier(SPECIAL_SLOW_MULT)} to every runner crossing that row for ${SPECIAL_LINGER}s.`
  },
  {
    id: "beamColumn",
    icon: "special-column",
    name: "Vertical Slow Beam",
    description: () =>
      `Applies ${formatMultiplier(SPECIAL_SLOW_MULT)} to runners crossing that column for ${SPECIAL_LINGER}s.`
  },
  {
    id: "gravity",
    icon: "special-gravity",
    name: "Gravity Well",
    description: () =>
      `A ${SPECIAL_RADIUS}-tile aura that drags the runner inward, scaling speed from ${formatMultiplier(
        GRAVITY_MAX_MULT
      )} at the rim down to ${formatMultiplier(GRAVITY_MIN_MULT)} at the core.`
  },
  {
    id: "lightning",
    icon: "special-lightning",
    name: "Lightning Strike",
    description: () =>
      `Zaps runners within ${SPECIAL_RADIUS} tiles, stunning them for ${LIGHTNING_STUN}s before recharging for ${LIGHTNING_COOLDOWN}s.`
  }
];

function formatMultiplier(value) {
  return `${value.toFixed(2)}x`;
}

canvas.width = CANVAS_WIDTH;
canvas.height = CANVAS_HEIGHT;

const seedInput = document.getElementById("seedInput");
const newGameBtn = document.getElementById("newGame");
const randomSeedBtn = document.getElementById("randomSeed");
const setSeedBtn = document.getElementById("setSeed");
const editRetryBtn = document.getElementById("editRetry");
const timerEl = document.getElementById("timer");
const timerStatusEl = document.getElementById("timerStatus");
const statusBoard = document.getElementById("statusBoard");
const wallsCard = document.getElementById("wallsCard");
const singleCard = document.getElementById("singleCard");
const specialCard = document.getElementById("specialCard");
const wallsValueEl = document.getElementById("wallsValue");
const singleValueEl = document.getElementById("singleValue");
const specialValueEl = document.getElementById("specialValue");
const specialPreviewCanvas = document.getElementById("specialPreview");
const specialPreviewCtx = specialPreviewCanvas?.getContext("2d");
const scoreEl = document.getElementById("score");
const phaseEl = document.getElementById("phase");
const specialInfoEl = document.getElementById("specialInfo");
const menuOverlay = document.getElementById("menuOverlay");
const pauseOverlay = document.getElementById("pauseOverlay");
const loadingOverlay = document.getElementById("loadingOverlay");
const loadingText = document.getElementById("loadingText");
const hud = document.getElementById("gameHud");
const menuSingleBtn = document.getElementById("menuSingle");
const menuQuitBtn = document.getElementById("menuQuit");
const resumeBtn = document.getElementById("resumeBtn");
const pauseMenuBtn = document.getElementById("pauseMenuBtn");
const menuButton = document.getElementById("menuButton");
const catalogueButton = document.getElementById("catalogueButton");
const catalogueOverlay = document.getElementById("catalogueOverlay");
const closeCatalogueBtn = document.getElementById("closeCatalogue");
const catalogueListEl = document.getElementById("catalogueList");
const resultPopup = document.getElementById("resultPopup");
const resultCard = resultPopup?.querySelector(".result-card");
const popupMessageEl = document.getElementById("popupMessage");
const popupEmojiEl = document.getElementById("popupEmoji");
const popupCloseBtn = document.getElementById("closePopup");
const shareResultBtn = document.getElementById("shareResult");

const state = {
  rng: mulberry32(1),
  seed: "",
  building: true,
  buildTimeLeft: 0,
  coins: 0,
  coinBudget: 0,
  singleBlocks: 0,
  singleBudget: 0,
  playerBlocks: [],
  playerSingles: [],
  playerGrid: createEmptyGrid(),
  baseGrid: null,
  aiGrid: null,
  hoverCell: null,
  floatingTexts: [],
  buildMode: "normal",
  specialTemplate: null,
  playerSpecial: null,
  aiSpecial: null,
  baseNeutralSpecials: [],
  neutralSpecials: [],
  race: null,
  results: { player: null, ai: null, winner: null },
  mode: "menu",
  paused: false,
  waitingForSpecial: false,
  catalogueOpen: false
};
let padPulseTimer = 0;
let cataloguePrevPaused = false;

seedInput.value = Math.floor(Math.random() * 1e9).toString();
setupListeners();
showMainMenu();
let lastFrame = performance.now();
let accumulator = 0;
requestAnimationFrame(loop);

function setupListeners() {
  newGameBtn.addEventListener("click", () => startGame(seedInput.value.trim()));
  randomSeedBtn.addEventListener("click", () => {
    seedInput.value = Math.floor(Math.random() * 1e9).toString();
    startGame(seedInput.value);
  });
  setSeedBtn.addEventListener("click", () => {
    let value = seedInput.value.trim();
    if (!value) {
      value = Math.floor(Math.random() * 1e9).toString();
      seedInput.value = value;
    }
    startGame(value);
  });
  editRetryBtn?.addEventListener("click", editAndRetry);
  wallsCard?.addEventListener("click", () => {
    if (!state.building || state.coins <= 0) return;
    setBuildMode("normal");
  });
  specialCard?.addEventListener("click", () => {
    if (!state.building || state.playerSpecial.placed) return;
    setBuildMode("special");
  });
  singleCard?.addEventListener("click", () => {
    if (!state.building || state.singleBlocks <= 0) return;
    setBuildMode("single");
  });
  canvas.addEventListener("click", handleCanvasClick);
  canvas.addEventListener("contextmenu", handleRightClick);
  canvas.addEventListener("mousemove", handleMouseMove);
  canvas.addEventListener("mouseleave", () => (state.hoverCell = null));
  popupCloseBtn.addEventListener("click", hideResultPopup);
  menuSingleBtn.addEventListener("click", () => startFromMenu());
  menuQuitBtn.addEventListener("click", () => {
    window.close();
  });
  menuButton.addEventListener("click", () => {
    showMainMenu();
  });
  resumeBtn.addEventListener("click", resumeGame);
  pauseMenuBtn.addEventListener("click", () => {
    showMainMenu();
    hidePause();
  });
  catalogueButton?.addEventListener("click", openCatalogue);
  closeCatalogueBtn?.addEventListener("click", closeCatalogue);
  catalogueOverlay?.addEventListener("click", (evt) => {
    if (evt.target === catalogueOverlay) closeCatalogue();
  });
  shareResultBtn?.addEventListener("click", handleShareResult);
  document.addEventListener("keydown", (evt) => {
    if (evt.key === "Escape" && state.catalogueOpen) {
      closeCatalogue();
      return;
    }
    if (evt.key === "Escape" && state.mode === "game") {
      if (state.paused) resumeGame();
      else showPause();
    }
  });
}

function startGame(seedText) {
  const safeSeed = seedText || Date.now().toString();
  state.seed = safeSeed;
  seedInput.value = safeSeed;
  state.rng = mulberry32(hashSeed(safeSeed));
  closeCatalogue();

  const baseGeneration = generateBaseGrid(state.rng);
  state.baseGrid = baseGeneration.grid;
  state.baseNeutralSpecials = baseGeneration.neutralSpecial ? [baseGeneration.neutralSpecial] : [];
  state.neutralSpecials = state.baseNeutralSpecials.map(cloneSpecial);
  state.playerGrid = cloneGrid(state.baseGrid);
  state.aiGrid = null;
  state.coins = randomInt(state.rng, 10, 21);
  state.coinBudget = state.coins;
  const singleCount = state.rng() < 0.1 ? 2 : 1;
  state.singleBlocks = singleCount;
  state.singleBudget = singleCount;
  state.playerBlocks = [];
  state.playerSingles = [];
  const specialType = pickSpecialType(state.rng);
  state.specialTemplate = createSpecialTemplate(specialType);
  state.playerSpecial = createSpecialTemplate(specialType);
  state.aiSpecial = null;
  state.building = true;
  state.buildMode = "normal";
  state.buildTimeLeft = BUILD_DURATION / 1000;
  state.hoverCell = null;
  state.floatingTexts = [];
  state.race = null;
  state.results = { player: null, ai: null, winner: null };
  state.waitingForSpecial = false;
  setBuildMode("normal");
  updateSpecialInfo();
  updatePhaseLabel("Phase: Build");
  hideResultPopup();
  state.mode = "game";
  state.paused = false;
  hud.classList.remove("hidden");
}

function editAndRetry() {
  if (!state.seed) return;
  state.building = true;
  state.buildTimeLeft = BUILD_DURATION / 1000;
  state.waitingForSpecial = false;
  state.race = null;
  state.results = { player: null, ai: null, winner: null };
  resetPadStates(state.playerGrid);
  resetPadStates(state.aiGrid);
  if (state.playerSpecial) state.playerSpecial.effectTimer = 0;
  if (state.aiSpecial) state.aiSpecial.effectTimer = 0;
  state.neutralSpecials = state.baseNeutralSpecials.map(cloneSpecial);
  updatePhaseLabel("Phase: Build");
  hideResultPopup();
  updateHud();
}

function resetPadStates(grid) {
  if (!grid) return;
  for (let y = 0; y < GRID_SIZE; y++) {
    for (let x = 0; x < GRID_SIZE; x++) {
      if (grid[y][x] === CELL_SPEED_USED) grid[y][x] = CELL_SPEED;
      else if (grid[y][x] === CELL_SLOW_USED) grid[y][x] = CELL_SLOW;
      else if (grid[y][x] === CELL_DETOUR_USED) grid[y][x] = CELL_DETOUR;
      else if (grid[y][x] === CELL_STONE_USED) grid[y][x] = CELL_STONE;
      else if (grid[y][x] === CELL_REWIND_USED) grid[y][x] = CELL_REWIND;
    }
  }
}

function startFromMenu() {
  showLoadingOverlay("Preparing...");
  requestAnimationFrame(() => {
    startGame(seedInput.value);
    hideLoadingOverlay();
    hideMainMenu();
  });
}

function hasBuildResources() {
  return (state.coins || 0) > 0 || (state.singleBlocks || 0) > 0;
}

function allStructuresPlaced() {
  return (state.coins || 0) <= 0 && (state.singleBlocks || 0) <= 0 && Boolean(state.playerSpecial?.placed);
}

function handlePlacementComplete(evt) {
  updateResourceCards();
  if (allStructuresPlaced()) {
    if (!state.playerSpecial.placed && evt) {
      addFloatingText("Structures placed! Add your special to begin.", evt, "#99ff99");
      setBuildMode("special");
    }
    startRace();
  }
}

function releaseSpecialWaitIfResources(prevWalls, prevSingles) {
  if (!state.waitingForSpecial) return;
  if ((prevWalls === 0 && state.coins > 0) || (prevSingles === 0 && state.singleBlocks > 0)) {
    state.waitingForSpecial = false;
  }
}

function handleCanvasClick(evt) {
  if (!state.building) return;
  const cell = pointerToGrid(evt);
  if (!cell) return;

  if (state.buildMode === "special") {
    if (state.playerSpecial.placed) {
      addFloatingText("Special already placed", evt);
      return;
    }
    if (tryPlaceSpecial(state.playerGrid, cell.x, cell.y, state.playerSpecial)) {
      autoSelectNextBuildMode("special", state.playerSpecial?.placed);
      updateSpecialInfo();
      if (allStructuresPlaced()) {
        startRace();
      }
    } else {
      addFloatingText("Can't place special there", evt);
    }
    return;
  }

  if (state.buildMode === "single") {
    if (state.singleBlocks <= 0) {
      addFloatingText("No single blocks left!", evt, "#ff9c6b");
      if (state.coins > 0) setBuildMode("normal");
      return;
    }
    if (!tryPlaceSingleBlock(state.playerGrid, cell.x, cell.y)) {
      addFloatingText("Invalid placement", evt);
      return;
    }
    state.playerSingles.push({ x: cell.x, y: cell.y });
    state.singleBlocks -= 1;
    autoSelectNextBuildMode("single", state.singleBlocks <= 0);
    handlePlacementComplete(evt);
    return;
  }

  if (state.coins <= 0) {
    if (state.singleBlocks > 0) {
      addFloatingText("No walls left! Switch to the single block card.", evt, "#ffb36b");
      setBuildMode("single");
    } else if (!state.playerSpecial.placed) {
      addFloatingText("Structures placed! Add your special to begin.", evt, "#99ff99");
      setBuildMode("special");
    }
    return;
  }

  if (!tryPlaceBlock(state.playerGrid, cell.x, cell.y)) {
    addFloatingText("Invalid placement", evt);
    return;
  }
  state.playerBlocks.push({ x: cell.x, y: cell.y });
  state.coins -= 1;
  autoSelectNextBuildMode("normal", state.coins <= 0);
  handlePlacementComplete(evt);
}

function handleRightClick(evt) {
  evt.preventDefault();
  if (!state.building) return;
  const cell = pointerToGrid(evt);
  if (!cell) return;

  if (state.playerSpecial.placed && cell.x === state.playerSpecial.cell.x && cell.y === state.playerSpecial.cell.y) {
    state.playerGrid[cell.y][cell.x] = CELL_EMPTY;
    state.playerSpecial = createSpecialTemplate(state.specialTemplate.type);
    setBuildMode("normal");
    updateSpecialInfo();
    return;
  }

  const idx = state.playerBlocks.findIndex(
    (block) => cell.x >= block.x && cell.x <= block.x + 1 && cell.y >= block.y && cell.y <= block.y + 1
  );
  if (idx !== -1) {
    clearBlock(state.playerGrid, state.playerBlocks[idx].x, state.playerBlocks[idx].y);
    state.playerBlocks.splice(idx, 1);
    const prevCoins = state.coins;
    state.coins = Math.min(state.coins + 1, state.coinBudget);
    releaseSpecialWaitIfResources(prevCoins, state.singleBlocks);
    updateResourceCards();
    return;
  }

  const singleIdx = state.playerSingles.findIndex((block) => cell.x === block.x && cell.y === block.y);
  if (singleIdx === -1) return;
  if (state.playerGrid[cell.y][cell.x] === CELL_SINGLE) {
    state.playerGrid[cell.y][cell.x] = CELL_EMPTY;
  }
  state.playerSingles.splice(singleIdx, 1);
  const prevSingles = state.singleBlocks;
  state.singleBlocks = Math.min(state.singleBlocks + 1, state.singleBudget);
  releaseSpecialWaitIfResources(state.coins, prevSingles);
  updateResourceCards();
}

function handleMouseMove(evt) {
  if (!state.building) {
    state.hoverCell = null;
    return;
  }
  const cell = pointerToGrid(evt);
  state.hoverCell = cell;
}

function setBuildMode(mode = "normal") {
  if (!state.building) {
    mode = "normal";
  } else if (mode === "special" && state.playerSpecial?.placed) {
    mode = "normal";
  }
  if (mode === "normal" && state.coins <= 0) {
    if (state.singleBlocks > 0) mode = "single";
    else if (!state.playerSpecial?.placed) mode = "special";
  }
  if (mode === "single" && state.singleBlocks <= 0) {
    if (state.coins > 0) mode = "normal";
    else if (!state.playerSpecial?.placed) mode = "special";
    else mode = "normal";
  }
  state.buildMode = mode;
  updateCurrencySelection();
}

function isModeAvailable(mode) {
  if (!state.building) return false;
  if (mode === "normal") return state.coins > 0;
  if (mode === "single") return state.singleBlocks > 0;
  if (mode === "special") return state.playerSpecial && !state.playerSpecial.placed;
  return false;
}

function autoSelectNextBuildMode(currentMode, shouldSwitch = true) {
  if (!state.building || !shouldSwitch) return false;
  const startIndex = BUILD_MODE_ORDER.indexOf(currentMode ?? state.buildMode);
  const baseIndex = startIndex >= 0 ? startIndex : BUILD_MODE_ORDER.indexOf(state.buildMode);
  for (let i = 1; i <= BUILD_MODE_ORDER.length; i++) {
    const idx = ((baseIndex >= 0 ? baseIndex : -1) + i + BUILD_MODE_ORDER.length) % BUILD_MODE_ORDER.length;
    const nextMode = BUILD_MODE_ORDER[idx];
    if (!isModeAvailable(nextMode) || nextMode === state.buildMode) continue;
    setBuildMode(nextMode);
    showModeSwitchMessage(nextMode);
    return true;
  }
  return false;
}

function buildModeLabel(mode) {
  if (mode === "normal") return "Walls";
  if (mode === "single") return "Singles";
  if (mode === "special") return "Special";
  return "Build";
}

function showModeSwitchMessage(mode) {
  if (state.mode !== "game") return;
  const label = buildModeLabel(mode);
  state.floatingTexts.push({
    text: `Switched to ${label}`,
    x: CANVAS_WIDTH / 2,
    y: 70,
    life: 1.2,
    color: "#9cffaf"
  });
}

function renderSpecialPreview() {
  if (!specialPreviewCtx || !specialPreviewCanvas) return;
  const ctxPreview = specialPreviewCtx;
  ctxPreview.clearRect(0, 0, specialPreviewCanvas.width, specialPreviewCanvas.height);
  if (!state.playerSpecial) return;
  const previewSpecial = { ...state.playerSpecial, placed: true, cell: { x: 0, y: 0 } };
  const palette = specialPaletteForCell(previewSpecial, 0, 0);
  if (!palette) return;
  drawSpecialBlockSprite(0, 0, palette, ctxPreview, 0);
}

function tryPlaceBlock(grid, gx, gy) {
  if (!canPlaceBlock(grid, gx, gy)) return false;
  placeBlock(grid, gx, gy, CELL_PLAYER);
  ensureOpenings(grid);
  if (!hasPath(grid)) {
    clearBlock(grid, gx, gy);
    ensureOpenings(grid);
    return false;
  }
  return true;
}

function tryPlaceSingleBlock(grid, gx, gy) {
  if (!canPlaceSingle(grid, gx, gy)) return false;
  grid[gy][gx] = CELL_SINGLE;
  ensureOpenings(grid);
  if (!hasPath(grid)) {
    grid[gy][gx] = CELL_EMPTY;
    ensureOpenings(grid);
    return false;
  }
  return true;
}

function tryPlaceSpecial(grid, gx, gy, special) {
  if (!isCellAvailableForSpecial(grid, gx, gy)) return false;
  grid[gy][gx] = CELL_SPECIAL;
  ensureOpenings(grid);
  if (!hasPath(grid)) {
    grid[gy][gx] = CELL_EMPTY;
    ensureOpenings(grid);
    return false;
  }
  special.cell = { x: gx, y: gy };
  special.placed = true;
  special.effectTimer = 0;
  if (state.waitingForSpecial) {
    state.waitingForSpecial = false;
    startRace();
  }
  return true;
}

function startRace(forceStart = false) {
  if (!state.building) return;
  if (!state.playerSpecial.placed && !forceStart) {
    if (!state.waitingForSpecial) {
      if (hasBuildResources()) {
        notifySpecialNeeded();
      }
      state.waitingForSpecial = true;
    }
    return;
  }
  state.waitingForSpecial = false;
  state.building = false;
  state.buildTimeLeft = 0;
  state.hoverCell = null;
  setBuildMode("normal");

  const playerGrid = cloneGrid(state.playerGrid);
  const playerSpecial = cloneSpecial(state.playerSpecial);

  if (!state.aiGrid || !state.aiSpecial) {
    const aiLayout = buildAiLayout();
    state.aiGrid = aiLayout.grid;
    state.aiSpecial = aiLayout.special;
  }

  const playerRunner = createRunner("You", playerGrid, playerSpecial, state.baseNeutralSpecials);
  const aiRunner = createRunner("AI", state.aiGrid, cloneSpecial(state.aiSpecial), state.baseNeutralSpecials);

  if (!playerRunner.path.length || !aiRunner.path.length) {
    const fallbackPath = [
      { x: ENTRANCE_X, y: GRID_SIZE },
      { x: ENTRANCE_X, y: GRID_SIZE + 1 },
      { x: ENTRANCE_X, y: GRID_SIZE + 2 },
      { x: ENTRANCE_X, y: GRID_SIZE + 3 },
      { x: ENTRANCE_X, y: GRID_SIZE + 4 },
      { x: ENTRANCE_X, y: 0 },
      { x: ENTRANCE_X, y: -1 }
    ];
    if (!playerRunner.path.length) {
      playerRunner.path = fallbackPath.slice();
      playerRunner.segmentIndex = 0;
      playerRunner.segmentProgress = 0;
      playerRunner.segmentLengths = computeSegmentLengths(playerRunner.path);
    }
    if (!aiRunner.path.length) {
      aiRunner.path = fallbackPath.slice();
      aiRunner.segmentIndex = 0;
      aiRunner.segmentProgress = 0;
      aiRunner.segmentLengths = computeSegmentLengths(aiRunner.path);
    }
  }

  state.race = {
    runners: [playerRunner, aiRunner],
    finished: false,
    elapsed: null,
    elapsedTime: 0
  };
  state.results = { player: null, ai: null, winner: null };
  updatePhaseLabel("Phase: Race");
}

function buildAiLayout() {
  const grid = cloneGrid(state.baseGrid);
  const special = createSpecialTemplate(state.specialTemplate.type);
  const tries = state.coinBudget;
  let currentScore = evaluateGridForAi(grid);
  for (let i = 0; i < tries; i++) {
    const placement = findBestAiPlacement(grid, currentScore);
    if (!placement) break;
    placeBlock(grid, placement.x, placement.y, CELL_PLAYER);
    ensureOpenings(grid);
    currentScore = placement.score;
  }
  let singleScore = currentScore;
  for (let i = 0; i < (state.singleBudget || 0); i++) {
    const single = findBestAiSinglePlacement(grid, singleScore);
    if (!single) break;
    grid[single.y][single.x] = CELL_SINGLE;
    ensureOpenings(grid);
    singleScore = single.score;
  }
  placeAiSpecial(grid, special);
  return { grid, special };
}

function findBestAiPlacement(grid, currentScore) {
  let best = null;
  const basePath = computePath(grid);
  const targeted = [];
  basePath.forEach((node) => {
    for (const [ox, oy] of [
      [-1, -1],
      [0, -1],
      [-1, 0],
      [0, 0]
    ]) {
      targeted.push({ x: node.x + ox, y: node.y + oy });
    }
  });
  const candidates = targeted.concat(generateRandomCandidates(grid, 160));
  for (const cand of candidates) {
    if (!canPlaceBlock(grid, cand.x, cand.y)) continue;
    placeBlock(grid, cand.x, cand.y, CELL_PLAYER);
    ensureOpenings(grid);
    const score = evaluateGridForAi(grid);
    clearBlock(grid, cand.x, cand.y);
    ensureOpenings(grid);
    if (score === -Infinity || score < currentScore) continue;
    if (!best || score > best.score) {
      best = { x: cand.x, y: cand.y, score };
    }
  }
  return best;
}

function generateRandomCandidates(grid, count) {
  const results = [];
  for (let i = 0; i < count; i++) {
    results.push({
      x: randomInt(state.rng, 0, GRID_SIZE - 2),
      y: randomInt(state.rng, 1, GRID_SIZE - 3)
    });
  }
  return results;
}

function findBestAiSinglePlacement(grid, currentScore) {
  let best = null;
  const basePath = computePath(grid);
  const candidates = new Set();
  basePath.forEach((node) => {
    candidates.add(key(node.x, node.y));
    MOVES.forEach((move) => {
      const nx = node.x + move.dx;
      const ny = node.y + move.dy;
      if (isInsideGrid(nx, ny)) candidates.add(key(nx, ny));
    });
  });
  const extras = generateRandomSingleCandidates(160);
  extras.forEach((c) => candidates.add(key(c.x, c.y)));
  for (const entry of candidates) {
    const [cx, cy] = entry.split(",").map(Number);
    if (!canPlaceSingle(grid, cx, cy)) continue;
    grid[cy][cx] = CELL_SINGLE;
    ensureOpenings(grid);
    const score = evaluateGridForAi(grid);
    grid[cy][cx] = CELL_EMPTY;
    ensureOpenings(grid);
    if (score === -Infinity || score < currentScore) continue;
    if (!best || score > best.score) {
      best = { x: cx, y: cy, score };
    }
  }
  return best;
}

function generateRandomSingleCandidates(count) {
  const out = [];
  for (let i = 0; i < count; i++) {
    out.push({
      x: randomInt(state.rng, 0, GRID_SIZE - 1),
      y: randomInt(state.rng, 1, GRID_SIZE - 2)
    });
  }
  return out;
}

function placeAiSpecial(grid, special) {
  const basePath = computePath(grid);
  if (!basePath.length) return;
  const candidates = new Set();
  basePath.forEach((node) => {
    if (node.x >= 0 && node.x < GRID_SIZE && node.y >= 0 && node.y < GRID_SIZE) {
      candidates.add(key(node.x, node.y));
    }
    MOVES.forEach((move) => {
      const nx = node.x + move.dx;
      const ny = node.y + move.dy;
      if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
        candidates.add(key(nx, ny));
      }
    });
  });
  for (let i = 0; i < 120; i++) {
    const gx = randomInt(state.rng, 0, GRID_SIZE - 1);
    const gy = randomInt(state.rng, 1, GRID_SIZE - 2);
    candidates.add(key(gx, gy));
  }
  let best = null;
  for (const entry of candidates) {
    const [x, y] = entry.split(",").map(Number);
    if (!isCellAvailableForSpecial(grid, x, y)) continue;
    const original = grid[y][x];
    grid[y][x] = CELL_SPECIAL;
    ensureOpenings(grid);
    const pathInfo = analyzePath(grid);
    if (!pathInfo) {
      grid[y][x] = original;
      ensureOpenings(grid);
      continue;
    }
    const score =
      pathInfo.totalDistance + pathInfo.padScore + scoreSpecialPlacement(pathInfo, special.type, { x, y });
    grid[y][x] = original;
    ensureOpenings(grid);
    if (!best || score > best.score) {
      best = { x, y, score };
    }
  }
  if (best) {
    grid[best.y][best.x] = CELL_SPECIAL;
    special.cell = { x: best.x, y: best.y };
    special.placed = true;
  }
}

function createRunner(label, grid, special, neutralSpecials = []) {
  const path = computePath(grid);
  return {
    label,
    grid,
    special,
    neutralSpecials: cloneNeutralSpecials(neutralSpecials),
    path,
    segmentIndex: 0,
    segmentProgress: 0,
    segmentLengths: computeSegmentLengths(path),
    finished: !path.length,
    resultTime: null,
    worldPos: null,
    elapsedTime: 0,
    effects: {
      slowTimer: 0,
      fastTimer: 0,
      areaTimer: 0,
      speedMultiplier: 1,
      gravityActive: false,
      gravityPull: null,
      gravityOffset: null,
      stunTimer: 0,
      medusaActive: false,
      medusaDir: null,
      lastDir: null,
      lastStep: null,
      neutralSlowTimer: 0
    }
  };
}

function updateRace(delta) {
  if (!state.race) return;
  let allFinished = true;
  state.race.elapsedTime += delta;
  state.race.runners.forEach((runner) => {
    if (runner.finished) return;
    allFinished = false;
    if (!runner.path.length) {
      runner.finished = true;
      recordResult(runner, null);
      return;
    }
    updateRunnerEffects(runner, delta);
    const speed = NPC_SPEED * runner.effects.speedMultiplier;
    let remainingDistance = speed * delta;
    let timeConsumed = 0;
    while (remainingDistance > 0 && runner.segmentIndex < runner.segmentLengths.length) {
      const dirVector = segmentDirectionVector(runner.path, runner.segmentIndex);
      const dirStep = segmentStep(runner.path, runner.segmentIndex);
      if (dirVector) {
        runner.effects.lastDir = dirVector;
        runner.effects.lastStep = dirStep;
      }
      const segmentLength = runner.segmentLengths[runner.segmentIndex] || 0;
      if (segmentLength === 0) {
        runner.segmentIndex++;
        runner.segmentProgress = 0;
        continue;
      }
      const segmentRemaining = segmentLength - runner.segmentProgress;
      if (remainingDistance < segmentRemaining) {
        runner.segmentProgress += remainingDistance;
        timeConsumed += remainingDistance / speed;
        remainingDistance = 0;
      } else {
        remainingDistance -= segmentRemaining;
        timeConsumed += segmentRemaining / speed;
        runner.segmentIndex++;
        runner.segmentProgress = 0;
        triggerPanelForRunner(runner);
      }
    }
    runner.worldPos = runnerWorldPosition(runner);
    checkPanelUnderRunner(runner);
    updateSpecialArea(runner, delta);
    updateNeutralSpecialEffects(runner, delta);
    runner.elapsedTime += timeConsumed;
    updatePadEffectStates(runner);
    if (runner.segmentIndex >= runner.segmentLengths.length) {
      runner.finished = true;
      runner.resultTime = runner.elapsedTime;
      recordResult(runner, runner.resultTime);
    }
  });
  if (state.race.finished) return;
  if (allFinished) {
    state.race.finished = true;
    const playerTime = state.results.player ?? 0;
    const aiTime = state.results.ai ?? 0;
    state.race.elapsed = Math.max(playerTime, aiTime);
    state.race.elapsedTime = state.race.elapsed;
    decideWinner();
    updatePhaseLabel("Phase: Complete");
  }
}

function recordResult(runner, time) {
  if (runner.label === "You") {
    state.results.player = time;
  } else {
    state.results.ai = time;
  }
}

function decideWinner() {
  const player = state.results.player;
  const ai = state.results.ai;
  if (player == null && ai == null) {
    state.results.winner = "No valid runs";
  } else if (player == null) {
    state.results.winner = "AI wins!";
  } else if (ai == null) {
    state.results.winner = "You win!";
  } else if (player > ai) {
    state.results.winner = "You win!";
  } else if (player < ai) {
    state.results.winner = "AI wins!";
  } else {
    state.results.winner = "Tie!";
  }
  showResultPopup();
}

function updateRunnerEffects(runner, delta) {
  const effects = runner.effects;
  if (effects.slowTimer > 0) effects.slowTimer = Math.max(0, effects.slowTimer - delta);
  if (effects.stunTimer > 0) effects.stunTimer = Math.max(0, effects.stunTimer - delta);
  if (effects.neutralSlowTimer > 0) effects.neutralSlowTimer = Math.max(0, effects.neutralSlowTimer - delta);
  if (effects.stunTimer > 0) {
    runner.effects.speedMultiplier = 0;
    return;
  }
  if (effects.fastTimer > 0) effects.fastTimer = Math.max(0, effects.fastTimer - delta);
  const specialType = runner.special?.type;
  if (effects.areaTimer > 0 && specialType !== "radius") {
    effects.areaTimer = Math.max(0, effects.areaTimer - delta);
  }
  let mult = 1;
  if (effects.slowTimer > 0) mult *= PANEL_SLOW_MULT;
  if (specialType === "radius") {
    if (effects.areaTimer > 0) {
      const ratio = Math.min(1, effects.areaTimer / FREEZING_BUILDUP);
      const auraMult = SPECIAL_SLOW_MULT - (SPECIAL_SLOW_MULT - FREEZING_MIN_MULT) * ratio;
      mult *= auraMult;
    }
  } else if (effects.areaTimer > 0) {
    mult *= SPECIAL_SLOW_MULT;
  }
  if (effects.neutralSlowTimer > 0) {
    mult *= SPECIAL_SLOW_MULT;
  }
  if (effects.fastTimer > 0) mult *= PANEL_FAST_MULT;
  if (effects.medusaActive) mult *= MEDUSA_SLOW_MULT;
  if (effects.gravityActive && effects.gravityPull) {
    const ratio = Math.max(0, Math.min(1, effects.gravityPull.distance / SPECIAL_RADIUS));
    const target = GRAVITY_MIN_MULT + (GRAVITY_MAX_MULT - GRAVITY_MIN_MULT) * ratio;
    mult *= target;
  }
  runner.effects.speedMultiplier = mult;
}

function triggerPanelForRunner(runner) {
  const node = runner.path[runner.segmentIndex];
  if (!node) return;
  const value = runner.grid[node.y]?.[node.x];
  if (isPadActiveCell(value)) {
    applyPanelEffect(runner, node.x, node.y, value);
  }
}

function checkPanelUnderRunner(runner) {
  const pos = runner.worldPos || runnerWorldPosition(runner);
  const radius = NPC_RADIUS;
  const minX = Math.max(0, Math.floor(pos.x - radius));
  const maxX = Math.min(GRID_SIZE - 1, Math.floor(pos.x + radius));
  const minY = Math.max(0, Math.floor(pos.y - radius));
  const maxY = Math.min(GRID_SIZE - 1, Math.floor(pos.y + radius));
  for (let gy = minY; gy <= maxY; gy++) {
    for (let gx = minX; gx <= maxX; gx++) {
      const value = runner.grid[gy][gx];
      if (isPadActiveCell(value)) {
        applyPanelEffect(runner, gx, gy, value);
      }
    }
  }
}

function applyPanelEffect(runner, x, y, value) {
  if (!isPadActiveCell(value)) return;
  const padType = padTypeFromCell(value);
  runner.grid[y][x] = padUsedVariant(value);
  if (padType === "speed") {
    runner.effects.fastTimer = PANEL_EFFECT_DURATION;
  } else if (padType === "slow") {
    runner.effects.slowTimer = PANEL_EFFECT_DURATION;
  } else if (padType === "detour") {
    triggerDetourPad(runner, x, y);
  } else if (padType === "stone") {
    triggerStonePad(runner);
  } else if (padType === "rewind") {
    triggerRewindPad(runner);
  }
  updateRunnerEffects(runner, 0);
}

function updatePadEffectStates(runner) {
  if (runner.effects.medusaActive) {
    const dir = runner.effects.lastDir;
    if (dir) {
      if (!runner.effects.medusaDir) {
        runner.effects.medusaDir = dir;
      } else {
        const dot = dir.x * runner.effects.medusaDir.x + dir.y * runner.effects.medusaDir.y;
        if (dot < 0.98) {
          runner.effects.medusaActive = false;
          runner.effects.medusaDir = null;
        }
      }
    }
  }
}

function triggerDetourPad(runner, x, y) {
  const lastStep = runner.effects.lastStep || stepFromDirVector(runner.effects.lastDir);
  if (!lastStep) return;
  const stepX = -lastStep.x;
  const stepY = -lastStep.y;
  if (stepX === 0 && stepY === 0) return;
  const forced = [{ x, y }];
  let currentX = x;
  let currentY = y;
  while (true) {
    const nextX = currentX + stepX;
    const nextY = currentY + stepY;
    if (!isInsideGrid(nextX, nextY)) break;
    if (!isWalkableCell(runner.grid, nextX, nextY)) break;
    forced.push({ x: nextX, y: nextY });
    currentX = nextX;
    currentY = nextY;
  }
  if (forced.length < 2) return;
  const finalCell = forced[forced.length - 1];
  const onward = computePathFromCell(runner.grid, finalCell);
  if (!onward.length) return;
  const tail = onward.slice(1);
  const newPath = forced.concat(tail);
  applyRunnerPath(runner, newPath);
}

function triggerStonePad(runner) {
  runner.effects.medusaActive = true;
  runner.effects.medusaDir = runner.effects.lastDir ? { ...runner.effects.lastDir } : null;
}

function triggerRewindPad(runner) {
  const restart = computePath(runner.grid);
  if (!restart.length) return;
  applyRunnerPath(runner, restart);
  runner.effects.fastTimer = 0;
  runner.effects.slowTimer = 0;
  runner.effects.medusaActive = false;
  runner.effects.medusaDir = null;
}

function applyRunnerPath(runner, newPath) {
  if (!newPath.length) return;
  runner.path = newPath;
  runner.segmentLengths = computeSegmentLengths(newPath);
  runner.segmentIndex = 0;
  runner.segmentProgress = 0;
  runner.worldPos = runnerWorldPosition(runner);
  runner.finished = false;
  runner.resultTime = null;
  runner.effects.lastDir = null;
  runner.effects.lastStep = null;
  runner.effects.gravityOffset = null;
  runner.effects.gravityActive = false;
  runner.effects.gravityPull = null;
  runner.effects.neutralSlowTimer = 0;
}

function stepFromDirVector(dir) {
  if (!dir) return null;
  return {
    x: dir.x > 0.1 ? 1 : dir.x < -0.1 ? -1 : 0,
    y: dir.y > 0.1 ? 1 : dir.y < -0.1 ? -1 : 0
  };
}

function updateSpecialArea(runner, delta) {
  const special = runner.special;
  if (!special?.placed || !special.cell) {
    runner.effects.areaTimer = 0;
    runner.effects.gravityActive = false;
    runner.effects.gravityPull = null;
    runner.effects.gravityOffset = decayGravityOffset(runner.effects.gravityOffset, delta);
    return;
  }
  const pos = runner.worldPos || runnerWorldPosition(runner);
  if (special.type === "gravity") {
    const centerX = special.cell.x + 0.5;
    const centerY = special.cell.y + 0.5;
    const dx = centerX - pos.x;
    const dy = centerY - pos.y;
    const dist = Math.hypot(dx, dy);
    if (dist <= SPECIAL_RADIUS) {
      runner.effects.gravityActive = true;
      const norm = dist === 0 ? 0 : 1 / dist;
      runner.effects.gravityPull = { x: dx * norm, y: dy * norm, distance: dist };
      runner.effects.gravityOffset = { x: dx * norm * 0.15, y: dy * norm * 0.15 };
    } else {
      runner.effects.gravityActive = false;
      runner.effects.gravityPull = null;
      runner.effects.gravityOffset = decayGravityOffset(runner.effects.gravityOffset, delta);
    }
    runner.effects.areaTimer = 0;
    return;
  }
  runner.effects.gravityActive = false;
  runner.effects.gravityPull = null;
  runner.effects.gravityOffset = decayGravityOffset(runner.effects.gravityOffset, delta);
  if (special.type === "radius") {
    if (isPointInsideSpecial(pos, special)) {
      runner.effects.areaTimer = Math.min(FREEZING_BUILDUP, runner.effects.areaTimer + delta);
    } else {
      const decayRate = FREEZING_BUILDUP / SPECIAL_LINGER;
      runner.effects.areaTimer = Math.max(0, runner.effects.areaTimer - decayRate * delta);
    }
    return;
  }
  if (special.type === "lightning") {
    special.cooldown = Math.max(0, (special.cooldown || 0) - delta);
    special.flashTimer = Math.max(0, (special.flashTimer || 0) - delta);
    const centerX = special.cell.x + 0.5;
    const centerY = special.cell.y + 0.5;
    const dist = Math.hypot(centerX - pos.x, centerY - pos.y);
    if (dist <= SPECIAL_RADIUS && special.cooldown <= 0 && runner.effects.stunTimer <= 0) {
      runner.effects.stunTimer = LIGHTNING_STUN;
      special.cooldown = LIGHTNING_COOLDOWN;
      special.flashTimer = 0.3;
    }
    runner.effects.areaTimer = 0;
    return;
  }
  if (isPointInsideSpecial(pos, special)) {
    special.effectTimer = SPECIAL_LINGER;
  } else if (special.effectTimer > 0) {
    special.effectTimer = Math.max(0, special.effectTimer - delta);
  }
  runner.effects.areaTimer = special.effectTimer;
}

function updateNeutralSpecialEffects(runner, delta) {
  const list = runner.neutralSpecials;
  if (!list?.length) return;
  const pos = runner.worldPos || runnerWorldPosition(runner);
  list.forEach((special) => {
    special.cooldown = Math.max(0, (special.cooldown || 0) - delta);
    special.flashTimer = Math.max(0, (special.flashTimer || 0) - delta);
    if (special.effectTimer > 0) {
      special.effectTimer = Math.max(0, special.effectTimer - delta);
    }
    if (!special.cell) return;
    if (special.type === "lightning") {
      if (special.cooldown <= 0 && isPointInsideSpecial(pos, special) && runner.effects.stunTimer <= 0) {
        runner.effects.stunTimer = LIGHTNING_STUN;
        special.cooldown = LIGHTNING_COOLDOWN;
        special.flashTimer = 0.3;
      }
      return;
    }
    if (special.type === "row" || special.type === "column") {
      if (isPointInsideSpecial(pos, special)) {
        runner.effects.neutralSlowTimer = SPECIAL_LINGER;
      }
    }
  });
}

function runnerWorldPosition(runner) {
  if (!runner.path.length) {
    return { x: ENTRANCE_X + 0.5, y: GRID_SIZE - 0.5 };
  }
  if (runner.segmentIndex >= runner.path.length - 1) {
    return centerOf(runner.path[runner.path.length - 1]);
  }
  const start = runner.path[runner.segmentIndex];
  const end = runner.path[runner.segmentIndex + 1];
  const startCenter = centerOf(start);
  const endCenter = centerOf(end);
  const segmentLength = runner.segmentLengths[runner.segmentIndex] || 1;
  const t = Math.min(1, runner.segmentProgress / segmentLength);
  const pos = {
    x: startCenter.x + (endCenter.x - startCenter.x) * t,
    y: startCenter.y + (endCenter.y - startCenter.y) * t
  };
  if (runner.effects.gravityOffset) {
    pos.x += runner.effects.gravityOffset.x;
    pos.y += runner.effects.gravityOffset.y;
  }
  return pos;
}

function updateState(delta) {
  padPulseTimer = (padPulseTimer + delta) % PAD_PULSE_PERIOD;
  if (state.building) {
    if (!state.paused) {
      state.buildTimeLeft = Math.max(0, state.buildTimeLeft - delta);
      if (state.buildTimeLeft <= 0) {
        startRace(true);
      }
    }
  } else if (state.race && !state.paused && !state.race.finished) {
    updateRace(delta);
  }
  updateFloatingTexts(delta);
  updateHud();
}
function updateHud() {
  if (state.mode === "menu") {
    timerEl.textContent = "--";
    timerStatusEl.textContent = "Awaiting run";
    if (scoreEl) scoreEl.textContent = "Score: --";
    updateResourceCards();
    return;
  }

  if (state.paused) {
    timerEl.textContent = "--";
    timerStatusEl.textContent = "Paused";
  } else if (state.building) {
    timerEl.textContent = `${Math.max(0, state.buildTimeLeft).toFixed(1)}s`;
    timerStatusEl.textContent = "Build phase";
  } else if (state.race && !state.race.finished) {
    const elapsed = state.race.elapsedTime || 0;
    timerEl.textContent = `${elapsed.toFixed(1)}s`;
    timerStatusEl.textContent = "Race in progress";
  } else if (state.race && state.race.finished && state.race.elapsed !== null) {
    timerEl.textContent = `${state.race.elapsed.toFixed(1)}s`;
    timerStatusEl.textContent = "Race complete";
  } else {
    timerEl.textContent = "--";
    timerStatusEl.textContent = "Ready";
  }
  if (scoreEl) scoreEl.textContent = formatScoreText();
  updateResourceCards();
}

function updateResourceCards() {
  if (!wallsValueEl || !specialValueEl) return;
  if (state.mode === "menu") {
    wallsValueEl.textContent = "--";
    if (singleValueEl) singleValueEl.textContent = "--";
    specialValueEl.textContent = "--";
    updateCurrencySelection(true);
    return;
  }
  wallsValueEl.textContent = state.coins != null ? state.coins : "--";
  if (singleValueEl) {
    singleValueEl.textContent = state.singleBlocks != null ? state.singleBlocks : "--";
  }
  const specialsRemaining = state.playerSpecial?.placed ? 0 : 1;
  specialValueEl.textContent = specialsRemaining.toString();
  updateCurrencySelection();
}

function updateCurrencySelection(forceDisabled = false) {
  if (wallsCard) {
    const canUseWalls = !forceDisabled && state.building && state.coins > 0;
    wallsCard.classList.toggle("disabled", !canUseWalls);
    wallsCard.classList.toggle("active", state.building && state.buildMode === "normal" && canUseWalls);
  }
  if (singleCard) {
    const canUseSingle = !forceDisabled && state.building && state.singleBlocks > 0;
    const isActive = state.building && state.buildMode === "single" && canUseSingle;
    singleCard.classList.toggle("disabled", !canUseSingle);
    singleCard.classList.toggle("active", isActive);
  }
  if (specialCard) {
    const canUseSpecial = !forceDisabled && state.building && !state.playerSpecial?.placed;
    const isActive = state.building && state.buildMode === "special" && canUseSpecial;
    specialCard.classList.toggle("disabled", !canUseSpecial);
    specialCard.classList.toggle("active", isActive);
  }
}

function formatScoreText() {
  const finished = !!(state.race && state.race.finished);
  const formatVal = (val) => {
    if (val == null) return finished ? "DNF" : "--";
    return `${val.toFixed(2)}s`;
  };
  const playerText = formatVal(state.results.player);
  const aiText = formatVal(state.results.ai);
  return `Score: You ${playerText} | AI ${aiText}`;
}

function formatLabelScore(label) {
  const finished = !!(state.race && state.race.finished);
  const valFor = (val) => {
    if (val == null) return finished ? " (DNF)" : " (--)";
    return ` (${val.toFixed(2)}s)`;
  };
  if (label.startsWith("You")) {
    return valFor(state.results.player);
  }
  if (label.startsWith("AI")) {
    return valFor(state.results.ai);
  }
  return "";
}


function draw() {
  ctx.fillStyle = "#050505";
  ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
  const views = getViewsForRender();
  views.forEach((view, index) => {
    const offsetX = index === 0 ? 0 : VIEW_RENDER_WIDTH + VIEW_GAP;
    drawView(view, offsetX);
  });
  if (state.building) {
    drawHoverPreview();
  }
  drawFloatingTexts();
}

function getViewsForRender() {
  if (state.building) {
    return [
      {
        label: "You",
        grid: state.playerGrid,
        special: state.playerSpecial,
        runner: null,
        overlay: null,
        neutralSpecials: state.neutralSpecials
      },
      {
        label: "AI Preview",
        grid: state.baseGrid,
        special: null,
        runner: null,
        overlay: "AI layout revealed at race",
        neutralSpecials: state.neutralSpecials
      }
    ];
  }
  if (state.race) {
    return state.race.runners.map((runner) => ({
      label: runner.label,
      grid: runner.grid,
      special: runner.special,
      runner,
      neutralSpecials: runner.neutralSpecials || state.neutralSpecials
    }));
  }
  return [
    {
      label: "You",
      grid: state.playerGrid,
      special: state.playerSpecial,
      runner: null,
      neutralSpecials: state.neutralSpecials
    },
    {
      label: "AI",
      grid: state.aiGrid || state.baseGrid,
      special: state.aiSpecial,
      runner: null,
      neutralSpecials: state.neutralSpecials
    }
  ];
}

function drawView(view, offsetX) {
  ctx.save();
  ctx.translate(offsetX != null ? offsetX : view.offset || 0, 0);
  ctx.fillStyle = "#0b0b0b";
  ctx.fillRect(0, 0, VIEW_RENDER_WIDTH, VIEW_HEIGHT);

  ctx.save();
  ctx.translate(VIEW_BORDER, 0);
  if (view.grid) {
    drawGridFrame();
    ctx.save();
    ctx.beginPath();
    ctx.rect(1, GRID_OFFSET_Y - CELL_SIZE + 1, VIEW_WIDTH - 2, (GRID_SIZE + 2) * CELL_SIZE - 2);
    ctx.clip();
    const neutralSpecials = view.neutralSpecials || [];
    neutralSpecials.forEach((spec) => drawSpecialOverlay({ ...spec, dimmed: true }));
    if (view.special?.placed) {
      drawSpecialOverlay(view.special);
    }
    drawCells(view.grid, view.special, neutralSpecials);
    drawEntrances();
    drawGridLines();
    if (view.runner && view.runner.worldPos) {
      const pos = view.runner.worldPos;
      ctx.fillStyle = view.runner.label === "You" ? "#ffcc00" : "#f19d38";
      ctx.beginPath();
      ctx.arc(pos.x * CELL_SIZE, GRID_OFFSET_Y + pos.y * CELL_SIZE, CELL_SIZE * NPC_RADIUS, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
    drawGridOutline();
  }
  ctx.restore();

  if (view.overlay) {
    ctx.fillStyle = "rgba(0, 0, 0, 0.65)";
    ctx.fillRect(0, 0, VIEW_RENDER_WIDTH, VIEW_HEIGHT);
    ctx.fillStyle = "rgba(255,255,255,0.8)";
    ctx.font = "14px system-ui";
    ctx.textAlign = "center";
    ctx.fillText(view.overlay, VIEW_RENDER_WIDTH / 2, VIEW_HEIGHT - 40);
    ctx.textAlign = "left";
  }

  if (!state.building && view.label.startsWith("AI")) {
    ctx.fillStyle = "rgba(0, 0, 0, 0.25)";
    ctx.fillRect(0, 0, VIEW_RENDER_WIDTH, VIEW_HEIGHT);
  }

  ctx.fillStyle = "#ffffff";
  ctx.font = "16px system-ui";
  ctx.textBaseline = "top";
  ctx.fillText(`${view.label}${formatLabelScore(view.label)}`, VIEW_BORDER + 10, 8);

  ctx.restore();
}

function drawSpecialOverlay(special) {
  ctx.save();
  if (special.dimmed) {
    ctx.globalAlpha *= 0.6;
  }
  if (special.type === "radius") {
    ctx.save();
    ctx.beginPath();
    ctx.rect(0, GRID_OFFSET_Y, VIEW_WIDTH, GRID_SIZE * CELL_SIZE);
    ctx.clip();
    const centerX = (special.cell.x + 0.5) * CELL_SIZE;
    const centerY = GRID_OFFSET_Y + (special.cell.y + 0.5) * CELL_SIZE;
    const radius = SPECIAL_RADIUS * CELL_SIZE;
    const innerRadius = radius - 6;
    const outerRingGrad = ctx.createRadialGradient(centerX, centerY, innerRadius, centerX, centerY, radius);
    outerRingGrad.addColorStop(0, "rgba(255,255,255,0.015)");
    outerRingGrad.addColorStop(1, "rgba(120, 190, 255, 0.14)");
    ctx.fillStyle = outerRingGrad;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.arc(centerX, centerY, innerRadius, 0, Math.PI * 2, true);
    ctx.fill();

    const innerGlow = ctx.createRadialGradient(centerX, centerY, innerRadius * 0.2, centerX, centerY, innerRadius * 0.9);
    innerGlow.addColorStop(0, "rgba(200, 235, 255, 0.08)");
    innerGlow.addColorStop(1, "rgba(200, 235, 255, 0)");
    ctx.fillStyle = innerGlow;
    ctx.beginPath();
    ctx.arc(centerX, centerY, innerRadius * 0.9, 0, Math.PI * 2);
    ctx.fill();
    drawSnowflake(centerX, centerY, innerRadius * 0.8);
    drawIcyArrows(centerX, centerY, innerRadius);
    ctx.restore();
  } else if (special.type === "gravity") {
    ctx.save();
    ctx.beginPath();
    ctx.rect(0, GRID_OFFSET_Y, VIEW_WIDTH, GRID_SIZE * CELL_SIZE);
    ctx.clip();
    const centerX = (special.cell.x + 0.5) * CELL_SIZE;
    const centerY = GRID_OFFSET_Y + (special.cell.y + 0.5) * CELL_SIZE;
    const radius = SPECIAL_RADIUS * CELL_SIZE;
    const grad = ctx.createRadialGradient(centerX, centerY, radius * 0.2, centerX, centerY, radius);
    grad.addColorStop(0, "rgba(150, 90, 220, 0.35)");
    grad.addColorStop(1, "rgba(60, 20, 80, 0)");
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,0.15)";
    ctx.lineWidth = 1.5;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  } else if (special.type === "lightning") {
    ctx.save();
    ctx.beginPath();
    ctx.rect(0, GRID_OFFSET_Y, VIEW_WIDTH, GRID_SIZE * CELL_SIZE);
    ctx.clip();
    const centerX = (special.cell.x + 0.5) * CELL_SIZE;
    const centerY = GRID_OFFSET_Y + (special.cell.y + 0.5) * CELL_SIZE;
    const ratio = 1 - Math.min(1, (special.cooldown || 0) / LIGHTNING_COOLDOWN);
    const radius = SPECIAL_RADIUS * CELL_SIZE;
    const ready = (special.cooldown || 0) <= 0;
    const colorReady = "rgba(255,215,130,0.15)";
    const colorInactive = "rgba(140,140,160,0.05)";
    ctx.shadowColor = ready ? "rgba(255,230,150,0.35)" : "rgba(200,210,250,0.15)";
    ctx.shadowBlur = ready ? 18 : 8;
    ctx.strokeStyle = ready ? colorReady : colorInactive;
    ctx.lineWidth = 2;
    ctx.setLineDash([]);
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.stroke();
    if (!ready) {
      const spokes = 10;
      for (let i = 0; i < spokes; i++) {
        const angle = (Math.PI * 2 * i) / spokes;
        const len = radius * ratio;
        // grey guide
        ctx.strokeStyle = "rgba(120,120,140,0.02)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(centerX + Math.cos(angle) * radius, centerY + Math.sin(angle) * radius);
        ctx.stroke();
        if (len > 0) {
          // gold fill growing outward from center
          ctx.shadowColor = "rgba(255,230,160,0.3)";
          ctx.shadowBlur = 16;
          ctx.strokeStyle = "rgba(255,215,130,0.12)";
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(centerX + Math.cos(angle) * len, centerY + Math.sin(angle) * len);
          ctx.stroke();
          ctx.shadowBlur = ready ? 18 : 8;
          ctx.shadowColor = ready ? "rgba(255,230,150,0.35)" : "rgba(200,210,250,0.15)";
        }
      }
    }
    if (ready || (special.flashTimer || 0) > 0) {
      drawLightningBolts(centerX, centerY, radius, ratio, (special.flashTimer || 0) > 0);
      if ((special.flashTimer || 0) > 0) {
        drawElectricStun(centerX, centerY, radius * 0.5, ratio);
      }
    }
    ctx.restore();
  } else if (special.type === "row") {
    const y = GRID_OFFSET_Y + special.cell.y * CELL_SIZE;
    const innerY = y + CELL_SIZE * 0.25;
    const innerH = CELL_SIZE * 0.5;
    const grad = ctx.createLinearGradient(0, innerY, 0, innerY + innerH);
    grad.addColorStop(0, "rgba(150, 110, 220, 0.14)");
    grad.addColorStop(0.5, "rgba(210, 160, 255, 0.28)");
    grad.addColorStop(1, "rgba(150, 110, 220, 0.14)");
    ctx.fillStyle = grad;
    ctx.fillRect(0, innerY, VIEW_WIDTH, innerH);
  } else if (special.type === "column") {
    const x = special.cell.x * CELL_SIZE;
    const innerX = x + CELL_SIZE * 0.25;
    const innerW = CELL_SIZE * 0.5;
    const grad = ctx.createLinearGradient(innerX, 0, innerX + innerW, 0);
    grad.addColorStop(0, "rgba(150, 110, 220, 0.14)");
    grad.addColorStop(0.5, "rgba(210, 160, 255, 0.28)");
    grad.addColorStop(1, "rgba(150, 110, 220, 0.14)");
    ctx.fillStyle = grad;
    ctx.fillRect(innerX, GRID_OFFSET_Y, innerW, GRID_SIZE * CELL_SIZE);
  }
  ctx.restore();
}

function drawCells(grid, specialForGrid, neutralSpecials = []) {
  if (!grid) return;
  for (let y = 0; y < GRID_SIZE; y++) {
    for (let x = 0; x < GRID_SIZE; x++) {
      const cell = grid[y][x];
      if (cell === CELL_EMPTY) continue;
      if (cell === CELL_STATIC) {
        drawStaticBlockSprite(x, y);
        continue;
      }
      if (cell === CELL_PLAYER) {
        drawPlayerBlockSprite(x, y);
        continue;
      }
      if (cell === CELL_SINGLE) {
        drawSingleBlockSprite(x, y);
        continue;
      }
      if (cell === CELL_SPECIAL) {
        const palette = specialPaletteForCell(specialForGrid, x, y);
        drawSpecialBlockSprite(x, y, palette);
        continue;
      }
      if (cell === CELL_STATIC_SPECIAL) {
        const palette = neutralPaletteForCell(neutralSpecials, x, y);
        drawSpecialBlockSprite(x, y, palette);
        continue;
      }
      if (isPadCell(cell)) {
        drawPadPlate(cell, x, y);
        continue;
      }
      ctx.fillStyle = cellColor(cell);
      ctx.fillRect(x * CELL_SIZE, GRID_OFFSET_Y + y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
    }
  }
}

function specialPaletteForCell(special, x, y) {
  if (!special?.placed || !special.cell) return null;
  if (special.cell.x !== x || special.cell.y !== y) return null;
  if (special.type === "radius") {
    return {
      outer: "#1c2f4f",
      inner: "#8ad0ff",
      border: "#1c4f8c",
      highlight: "rgba(255,255,255,0.25)",
      glyph: "✶",
      glyphScale: 1.5,
      glyphOffsetPx: { x: 0, y: 0.8 }
    };
  }
  if (special.type === "row" || special.type === "column") {
    return {
      outer: "#4e2a74",
      inner: "#b98cff",
      border: "#110517",
      highlight: "rgba(255,255,255,0.2)",
      arrow: special.type === "row" ? "horizontal" : "vertical"
    };
  }
  if (special.type === "gravity") {
    return {
      outer: "#2a0b3f",
      inner: "#9059d6",
      border: "#120620",
      highlight: "rgba(255,255,255,0.15)",
      glyph: "⊙",
      glyphScale: 0.88,
      glyphOffsetPx: { x: -0.6, y: 0.8 }
    };
  }
  if (special.type === "lightning") {
    return {
      outer: "#5a3b04",
      inner: "#ffcb64",
      border: "#1e1100",
      highlight: "rgba(255,255,255,0.22)",
      glyph: "Ψ",
      glyphScale: 1,
      glyphOffsetPx: { x: 0, y: 1.2 }
    };
  }
  return null;
}

function neutralPaletteForCell(neutralSpecials, x, y) {
  const target = findNeutralSpecial(neutralSpecials, x, y);
  if (!target)
    return {
      outer: "#2c2c2c",
      inner: "#5a5a5a",
      border: "#101010",
      highlight: "rgba(255,255,255,0.08)",
      glyph: "?"
    };
  if (target.type === "row" || target.type === "column") {
    return {
      outer: "#392048",
      inner: "#7a5a9e",
      border: "#110517",
      highlight: "rgba(255,255,255,0.12)",
      arrow: target.type === "row" ? "horizontal" : "vertical"
    };
  }
  if (target.type === "lightning") {
    return {
      outer: "#5a4a1c",
      inner: "#c7a956",
      border: "#1f1604",
      highlight: "rgba(255,255,255,0.12)",
      glyph: "Ψ",
      glyphOffsetPx: { x: 0, y: 2 }
    };
  }
  return {
    outer: "#2c2c2c",
    inner: "#5a5a5a",
    border: "#101010",
    highlight: "rgba(255,255,255,0.08)",
    glyph: "?",
    glyphColor: "#f5f5f5"
  };
}

function cellColor(cell) {
  switch (cell) {
    case CELL_STATIC:
      return "#6a6a6a";
    case CELL_PLAYER:
      return "#2ba84a";
    case CELL_SINGLE:
      return "#8a8a8a";
    case CELL_SPEED:
      return "rgba(240, 80, 80, 0.95)";
    case CELL_SLOW:
      return "rgba(80, 140, 255, 0.95)";
    case CELL_SPEED_USED:
      return "rgba(240, 80, 80, 0.25)";
    case CELL_SLOW_USED:
      return "rgba(80, 140, 255, 0.25)";
    case CELL_SPECIAL:
      return "#f5d06b";
    default:
      return "#777";
  }
}

function drawEntrances() {
  drawEntranceCell(ENTRANCE_X, -1, "F");
  drawEntranceCell(ENTRANCE_X, GRID_SIZE, "S");
}

function drawEntranceCell(gridX, gridY, label) {
  const baseX = gridX * CELL_SIZE;
  const baseY = GRID_OFFSET_Y + gridY * CELL_SIZE;
  ctx.fillStyle = "#090909";
  ctx.fillRect(baseX, baseY, CELL_SIZE, CELL_SIZE);
  ctx.strokeStyle = "rgba(255,255,255,0.12)";
  ctx.lineWidth = 1;
  ctx.strokeRect(baseX + 0.5, baseY + 0.5, CELL_SIZE - 1, CELL_SIZE - 1);
  ctx.fillStyle = "#f1f1f1";
  ctx.font = "bold 15px system-ui";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(label, baseX + CELL_SIZE / 2, baseY + CELL_SIZE / 2);
  ctx.textAlign = "left";
  ctx.textBaseline = "alphabetic";
}

function drawGridFrame() {
  ctx.fillStyle = "#000000";
  ctx.fillRect(-VIEW_BORDER, GRID_OFFSET_Y - CELL_SIZE, VIEW_WIDTH + VIEW_BORDER * 2, CELL_SIZE);
  ctx.fillRect(-VIEW_BORDER, GRID_OFFSET_Y + GRID_SIZE * CELL_SIZE, VIEW_WIDTH + VIEW_BORDER * 2, CELL_SIZE);
  ctx.fillRect(-VIEW_BORDER, GRID_OFFSET_Y - CELL_SIZE, VIEW_BORDER, (GRID_SIZE + 2) * CELL_SIZE);
  ctx.fillRect(VIEW_WIDTH, GRID_OFFSET_Y - CELL_SIZE, VIEW_BORDER, (GRID_SIZE + 2) * CELL_SIZE);
}

function drawGridOutline() {
  ctx.strokeStyle = "rgba(255,255,255,0.6)";
  ctx.lineWidth = 2;
  const left = 0.5;
  const right = VIEW_WIDTH - 0.5;
  const top = GRID_OFFSET_Y + 0.5;
  const bottom = GRID_OFFSET_Y + GRID_SIZE * CELL_SIZE - 0.5;
  const bumpTop = top - CELL_SIZE;
  const bumpBottom = bottom + CELL_SIZE;
  const entryLeft = ENTRANCE_X * CELL_SIZE + 0.5;
  const entryRight = (ENTRANCE_X + 1) * CELL_SIZE - 0.5;

  ctx.beginPath();
  ctx.moveTo(left, top);
  ctx.lineTo(entryLeft, top);
  ctx.lineTo(entryLeft, bumpTop);
  ctx.lineTo(entryRight, bumpTop);
  ctx.lineTo(entryRight, top);
  ctx.lineTo(right, top);
  ctx.lineTo(right, bottom);
  ctx.lineTo(entryRight, bottom);
  ctx.lineTo(entryRight, bumpBottom);
  ctx.lineTo(entryLeft, bumpBottom);
  ctx.lineTo(entryLeft, bottom);
  ctx.lineTo(left, bottom);
  ctx.closePath();
  ctx.stroke();
}

function drawGridLines() {
  ctx.strokeStyle = "rgba(255,255,255,0.12)";
  ctx.lineWidth = 1;
  for (let i = 0; i <= GRID_SIZE; i++) {
    ctx.beginPath();
    ctx.moveTo(0, GRID_OFFSET_Y + i * CELL_SIZE);
    ctx.lineTo(VIEW_WIDTH, GRID_OFFSET_Y + i * CELL_SIZE);
    ctx.stroke();
  }
  for (let i = 0; i <= GRID_SIZE; i++) {
    ctx.beginPath();
    ctx.moveTo(i * CELL_SIZE, GRID_OFFSET_Y);
    ctx.lineTo(i * CELL_SIZE, GRID_OFFSET_Y + GRID_SIZE * CELL_SIZE);
    ctx.stroke();
  }
}

function drawHoverPreview() {
  if (!state.hoverCell) return;
  ctx.save();
  ctx.translate(VIEW_BORDER, 0);
  ctx.beginPath();
  ctx.rect(1, GRID_OFFSET_Y - CELL_SIZE + 1, VIEW_WIDTH - 2, (GRID_SIZE + 2) * CELL_SIZE - 2);
  ctx.clip();
  const { x, y } = state.hoverCell;
  if (state.buildMode === "special") {
    if (!state.playerSpecial || state.playerSpecial.placed || !isCellAvailableForSpecial(state.playerGrid, x, y)) {
      ctx.restore();
      return;
    }
    ctx.fillStyle = "rgba(255,255,255,0.2)";
    ctx.fillRect(x * CELL_SIZE, GRID_OFFSET_Y + y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
    drawSpecialOverlay({ type: state.playerSpecial.type, cell: { x, y } });
  } else if (state.buildMode === "single") {
    if (!canPlaceSingle(state.playerGrid, x, y)) {
      ctx.restore();
      return;
    }
    const out = state.singleBlocks <= 0;
    ctx.fillStyle = out ? "rgba(255, 80, 80, 0.35)" : "rgba(255,255,255,0.15)";
    ctx.fillRect(x * CELL_SIZE, GRID_OFFSET_Y + y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
  } else {
    if (!canPlaceBlock(state.playerGrid, x, y)) {
      ctx.restore();
      return;
    }
    const outOfWalls = state.coins <= 0;
    ctx.fillStyle = outOfWalls ? "rgba(255, 80, 80, 0.4)" : "rgba(255,255,255,0.15)";
    ctx.fillRect(x * CELL_SIZE, GRID_OFFSET_Y + y * CELL_SIZE, CELL_SIZE * 2, CELL_SIZE * 2);
  }
  ctx.restore();
}

function drawFloatingTexts() {
  ctx.font = "16px system-ui";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  state.floatingTexts.forEach((t) => {
    ctx.fillStyle = applyAlpha(t.color || "#ff9999", Math.min(1, t.life));
    ctx.fillText(t.text, t.x, t.y);
  });
  ctx.textAlign = "left";
  ctx.textBaseline = "alphabetic";
}

function pointerToGrid(evt) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = CANVAS_WIDTH / rect.width;
  const scaleY = CANVAS_HEIGHT / rect.height;
  const px = (evt.clientX - rect.left) * scaleX;
  const py = (evt.clientY - rect.top) * scaleY;
  if (px < VIEW_BORDER || px > VIEW_BORDER + VIEW_WIDTH) return null;
  const gridX = Math.floor((px - VIEW_BORDER) / CELL_SIZE);
  const gridY = Math.floor((py - GRID_OFFSET_Y) / CELL_SIZE);
  if (gridX < 0 || gridX >= GRID_SIZE) return null;
  if (gridY < 0 || gridY >= GRID_SIZE) return null;
  return { x: gridX, y: gridY };
}

function updateFloatingTexts(delta) {
  state.floatingTexts = state.floatingTexts
    .map((t) => ({ ...t, life: t.life - delta, y: t.y - delta * 40 }))
    .filter((t) => t.life > 0);
}

function addFloatingText(text, evt, color) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = CANVAS_WIDTH / rect.width;
  const scaleY = CANVAS_HEIGHT / rect.height;
  const x = (evt.clientX - rect.left) * scaleX;
  const y = (evt.clientY - rect.top) * scaleY;
  state.floatingTexts.push({ text, x, y, life: 1.2, color });
}

function getSpecialTypeName(type) {
  if (type === "radius") return "Freezing Field";
  if (type === "row") return "Horizontal Slow Beam";
  if (type === "column") return "Vertical Slow Beam";
  if (type === "gravity") return "Gravity Well";
  if (type === "lightning") return "Lightning Strike";
  return "Unknown";
}


function updateSpecialInfo() {
  const status = state.playerSpecial.placed ? "placed" : "ready";
  if (specialInfoEl) {
    specialInfoEl.textContent = `Special: ${getSpecialTypeName(state.playerSpecial.type)} (${status})`;
  }
  updateResourceCards();
  renderSpecialPreview();
}

function updatePhaseLabel(text) {
  if (phaseEl) phaseEl.textContent = text;
}

function showResultPopup() {
  if (!state.results.winner) return;
  const { player, ai, winner } = state.results;
  let emoji = "😐";
  if (winner.includes("You")) emoji = "😄";
  else if (winner.includes("AI")) emoji = "😢";
  let detail = "";
  if (player != null && ai != null) {
    const diff = Math.abs(player - ai).toFixed(2);
    detail = `${winner} by ${diff}s`;
  } else {
    detail = winner;
  }
  popupEmojiEl.textContent = emoji;
  popupMessageEl.innerHTML = `${detail}<br><span class="popup-detail">You: ${player == null ? "DNF" : player.toFixed(
    2
  )}s &nbsp;|&nbsp; AI: ${ai == null ? "DNF" : ai.toFixed(2)}s</span>`;
  resultPopup.classList.remove("hidden");
  document.addEventListener("mousedown", handlePopupBackdrop, true);
}

function hideResultPopup() {
  resultPopup.classList.add("hidden");
  document.removeEventListener("mousedown", handlePopupBackdrop, true);
}

function handlePopupBackdrop(evt) {
  if (!resultCard) return;
  if (!resultCard.contains(evt.target)) {
    hideResultPopup();
  }
}

function handleShareResult() {
  const shareText = buildShareText();
  if (!shareText) return;
  if (navigator.clipboard?.writeText) {
    navigator.clipboard.writeText(shareText).catch(() => fallbackShare(shareText));
  } else {
    fallbackShare(shareText);
  }
}

function buildShareText() {
  const player = state.results.player;
  const ai = state.results.ai;
  if (player == null || ai == null) return `Seed: ${state.seed || "unknown"}`;
  const diff = player - ai;
  const pace = `${diff >= 0 ? "+" : ""}${diff.toFixed(2)}`;
  return `Pace ${pace} (Seed: ${state.seed || "unknown"})`;
}

function fallbackShare(text) {
  const temp = document.createElement("textarea");
  temp.value = text;
  temp.setAttribute("readonly", "");
  temp.style.position = "absolute";
  temp.style.left = "-9999px";
  document.body.appendChild(temp);
  temp.select();
  try {
    document.execCommand("copy");
  } finally {
    document.body.removeChild(temp);
  }
}

function notifySpecialNeeded() {
  const x = CANVAS_WIDTH / 2;
  const y = 50;
  state.floatingTexts.push({
    text: "Place your special to begin!",
    x,
    y,
    life: 1.5,
    color: "#ffdd66"
  });
}

function showMainMenu() {
  closeCatalogue();
  state.mode = "menu";
  state.paused = true;
  hud.classList.add("hidden");
  menuOverlay.classList.remove("hidden");
  pauseOverlay.classList.add("hidden");
  updateHud();
}

function hideMainMenu() {
  state.mode = "game";
  hud.classList.remove("hidden");
  menuOverlay.classList.add("hidden");
  updateHud();
}

function showLoadingOverlay(message = "Preparing...") {
  loadingText.textContent = message;
  loadingOverlay.classList.remove("hidden");
}

function hideLoadingOverlay() {
  loadingOverlay.classList.add("hidden");
}

function showPause() {
  state.paused = true;
  pauseOverlay.classList.remove("hidden");
  updateHud();
}

function hidePause() {
  state.paused = false;
  pauseOverlay.classList.add("hidden");
  updateHud();
}

function resumeGame() {
  hidePause();
  state.mode = "game";
}

function openCatalogue() {
  if (!catalogueOverlay || state.catalogueOpen) return;
  state.catalogueOpen = true;
  cataloguePrevPaused = state.paused;
  state.paused = true;
  populateCatalogueList();
  catalogueOverlay.classList.remove("hidden");
}

function closeCatalogue() {
  if (!catalogueOverlay || !state.catalogueOpen) return;
  state.catalogueOpen = false;
  state.paused = cataloguePrevPaused;
  catalogueOverlay.classList.add("hidden");
}

function populateCatalogueList() {
  if (!catalogueListEl) return;
  catalogueListEl.innerHTML = "";
  CATALOGUE_ITEMS.forEach((item) => {
    const entry = document.createElement("div");
    entry.className = "catalogue-item";
    const canvas = document.createElement("canvas");
    canvas.width = 48;
    canvas.height = 48;
    canvas.className = "catalogue-icon";
    const ctxIcon = canvas.getContext("2d");
    drawCatalogueIcon(ctxIcon, item.icon);
    const textWrap = document.createElement("div");
    textWrap.className = "catalogue-text";
    const title = document.createElement("h3");
    title.textContent = item.name;
    const body = document.createElement("p");
    const description = typeof item.description === "function" ? item.description() : item.description;
    body.textContent = description;
    textWrap.appendChild(title);
    textWrap.appendChild(body);
    entry.appendChild(canvas);
    entry.appendChild(textWrap);
    catalogueListEl.appendChild(entry);
  });
}

function drawCatalogueIcon(ctx, icon) {
  const w = ctx.canvas.width;
  const h = ctx.canvas.height;
  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = "#050505";
  ctx.fillRect(0, 0, w, h);
  switch (icon) {
    case "gate-start":
      drawCatalogueGateIcon(ctx, "S");
      break;
    case "gate-finish":
      drawCatalogueGateIcon(ctx, "F");
      break;
    case "wall-static":
      renderCatalogueSprite(ctx, (localCtx) => drawStaticBlockSprite(0, 0, localCtx, 0));
      break;
    case "wall-player":
      renderCatalogueSprite(ctx, (localCtx) => drawPlayerBlockSprite(0, 0, localCtx, 0));
      break;
    case "wall-single":
      renderCatalogueSprite(ctx, (localCtx) => drawSingleBlockSprite(0, 0, localCtx, 0));
      break;
    case "pad-speed":
      renderCatalogueSprite(ctx, (localCtx) => drawPadPlate(CELL_SPEED, 0, 0, localCtx, 0));
      break;
    case "pad-slow":
      renderCatalogueSprite(ctx, (localCtx) => drawPadPlate(CELL_SLOW, 0, 0, localCtx, 0));
      break;
    case "pad-detour":
      renderCatalogueSprite(ctx, (localCtx) => drawPadPlate(CELL_DETOUR, 0, 0, localCtx, 0));
      break;
    case "pad-stone":
      renderCatalogueSprite(ctx, (localCtx) => drawPadPlate(CELL_STONE, 0, 0, localCtx, 0));
      break;
    case "pad-rewind":
      renderCatalogueSprite(ctx, (localCtx) => drawPadPlate(CELL_REWIND, 0, 0, localCtx, 0));
      break;
    case "special-freeze":
      renderSpecialCatalogueSprite(ctx, "radius");
      break;
    case "special-row":
      renderSpecialCatalogueSprite(ctx, "row");
      break;
    case "special-column":
      renderSpecialCatalogueSprite(ctx, "column");
      break;
    case "special-gravity":
      renderSpecialCatalogueSprite(ctx, "gravity");
      break;
    case "special-lightning":
      renderSpecialCatalogueSprite(ctx, "lightning");
      break;
    default:
      drawCatalogueBlockIcon(ctx, "#2a2a2a", "#4a4a4a");
  }
}

function renderCatalogueSprite(ctx, drawFn) {
  const padX = (ctx.canvas.width - CELL_SIZE) / 2;
  const padY = (ctx.canvas.height - CELL_SIZE) / 2;
  ctx.save();
  ctx.translate(padX, padY);
  drawFn(ctx);
  ctx.restore();
}

function renderSpecialCatalogueSprite(ctx, type) {
  renderCatalogueSprite(ctx, (localCtx) => {
    const previewSpecial = { type, placed: true, cell: { x: 0, y: 0 } };
    const palette = specialPaletteForCell(previewSpecial, 0, 0);
    if (!palette) return;
    drawSpecialBlockSprite(0, 0, palette, localCtx, 0);
  });
}

function drawCatalogueGateIcon(ctx, label) {
  const w = ctx.canvas.width;
  const h = ctx.canvas.height;
  ctx.fillStyle = "#090909";
  ctx.fillRect(6, 6, w - 12, h - 12);
  ctx.strokeStyle = "rgba(255,255,255,0.25)";
  ctx.lineWidth = 2;
  ctx.strokeRect(7, 7, w - 14, h - 14);
  ctx.fillStyle = "#f5f5f5";
  ctx.font = "bold 20px 'Courier New', monospace";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(label, w / 2, h / 2);
}

function drawCatalogueBlockIcon(ctx, outer, inner) {
  const w = ctx.canvas.width;
  const h = ctx.canvas.height;
  ctx.fillStyle = outer;
  ctx.fillRect(5, 5, w - 10, h - 10);
  ctx.fillStyle = inner;
  ctx.fillRect(10, 10, w - 20, h - 20);
}

function loop(timestamp) {
  let delta = (timestamp - lastFrame) / 1000;
  lastFrame = timestamp;
  if (delta > MAX_FRAME_DELTA) delta = MAX_FRAME_DELTA;

  if (state.mode === "menu" || state.paused) {
    accumulator = 0;
    requestAnimationFrame(loop);
    return;
  }

  accumulator += delta;
  while (accumulator >= FIXED_TIMESTEP) {
    updateState(FIXED_TIMESTEP);
    accumulator -= FIXED_TIMESTEP;
  }
  draw();
  requestAnimationFrame(loop);
}
// GRID HELPERS ------------------------------------------------------------

function createEmptyGrid() {
  return Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(CELL_EMPTY));
}

function cloneGrid(grid) {
  return grid ? grid.map((row) => row.slice()) : createEmptyGrid();
}

function generateBaseGrid(rng) {
  let attempts = 0;
  while (attempts < 200) {
    const grid = createEmptyGrid();
    placeStaticBlocks(grid, rng);
    placePowerPanels(grid, rng);
    ensureOpenings(grid);
    const neutralSpecial = placeNeutralSpecial(grid, rng);
    if (hasPath(grid)) {
      return { grid, neutralSpecial };
    }
    attempts++;
  }
  const fallback = createEmptyGrid();
  ensureOpenings(fallback);
  return { grid: fallback, neutralSpecial: null };
}

function placeStaticBlocks(grid, rng) {
  const blockCount = randomInt(rng, 8, 18);
  let attempts = 0;
  while (attempts < blockCount * 6 && countBlocks(grid, CELL_STATIC) < blockCount) {
    const x = randomInt(rng, 0, GRID_SIZE - 2);
    const y = randomInt(rng, 2, GRID_SIZE - 4);
    if (Math.abs(x - ENTRANCE_X) <= 2) {
      attempts++;
      continue;
    }
    if (canPlaceBlock(grid, x, y)) {
      placeBlock(grid, x, y, CELL_STATIC);
    }
    attempts++;
  }
}

function placePowerPanels(grid, rng) {
  const candidates = [];
  for (let y = 1; y < GRID_SIZE - 1; y++) {
    for (let x = 0; x < GRID_SIZE; x++) {
      if (grid[y][x] === CELL_EMPTY && Math.abs(x - ENTRANCE_X) > 1) {
        candidates.push({ x, y });
      }
    }
  }
  shuffleWithRng(candidates, rng);
  const speedCount = 4;
  const slowCount = 2;
  for (let i = 0; i < speedCount && candidates.length; i++) {
    const cell = candidates.shift();
    grid[cell.y][cell.x] = CELL_SPEED;
    maybeUpgradePadToSpecial(grid, cell, rng, "speed");
  }
  for (let i = 0; i < slowCount && candidates.length; i++) {
    const cell = candidates.shift();
    grid[cell.y][cell.x] = CELL_SLOW;
    maybeUpgradePadToSpecial(grid, cell, rng, "slow");
  }
}

function placeNeutralSpecial(grid, rng) {
  const roll = rng();
  if (roll < 0.25) return null;
  const type = roll < 0.5 ? "lightning" : roll < 0.75 ? "row" : "column";
  const cells = [];
  for (let y = 1; y < GRID_SIZE - 1; y++) {
    for (let x = 0; x < GRID_SIZE; x++) {
      if (grid[y][x] === CELL_EMPTY && Math.abs(x - ENTRANCE_X) > 1) {
        cells.push({ x, y });
      }
    }
  }
  shuffleWithRng(cells, rng);
  for (const cell of cells) {
    grid[cell.y][cell.x] = CELL_STATIC_SPECIAL;
    ensureOpenings(grid);
    if (hasPath(grid)) {
      return createNeutralSpecial(type, cell);
    }
    grid[cell.y][cell.x] = CELL_EMPTY;
  }
  return null;
}

function maybeUpgradePadToSpecial(grid, cell, rng, baseType) {
  const chance = baseType === "slow" ? 0.15 : 0.01;
  if (rng() > chance) return;
  const options = [CELL_DETOUR, CELL_STONE, CELL_REWIND];
  const pick = options[Math.floor(rng() * options.length)];
  grid[cell.y][cell.x] = pick;
}

function ensureOpenings(grid) {
  grid[0][ENTRANCE_X] = CELL_EMPTY;
  grid[GRID_SIZE - 1][ENTRANCE_X] = CELL_EMPTY;
}

function isInsideGrid(x, y) {
  return x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE;
}

function canPlaceBlock(grid, gx, gy) {
  if (gx < 0 || gy < 0 || gx + 1 >= GRID_SIZE || gy + 1 >= GRID_SIZE) return false;
  for (let y = gy; y <= gy + 1; y++) {
    for (let x = gx; x <= gx + 1; x++) {
      if (grid[y][x] !== CELL_EMPTY) return false;
      if ((y === 0 || y === GRID_SIZE - 1) && x === ENTRANCE_X) return false;
    }
  }
  return true;
}

function canPlaceSingle(grid, gx, gy) {
  if (!isInsideGrid(gx, gy)) return false;
  if ((gy === 0 || gy === GRID_SIZE - 1) && gx === ENTRANCE_X) return false;
  return grid[gy][gx] === CELL_EMPTY;
}

function placeBlock(grid, gx, gy, type) {
  for (let y = gy; y <= gy + 1; y++) {
    for (let x = gx; x <= gx + 1; x++) {
      grid[y][x] = type;
    }
  }
}

function clearBlock(grid, gx, gy) {
  for (let y = gy; y <= gy + 1; y++) {
    for (let x = gx; x <= gx + 1; x++) {
      grid[y][x] = CELL_EMPTY;
    }
  }
}

function countBlocks(grid, type) {
  let total = 0;
  for (let y = 0; y < GRID_SIZE; y++) {
    for (let x = 0; x < GRID_SIZE; x++) {
      if (grid[y][x] === type) total++;
    }
  }
  return Math.floor(total / 4);
}

function isCellAvailableForSpecial(grid, gx, gy) {
  if (gx < 0 || gy < 0 || gx >= GRID_SIZE || gy >= GRID_SIZE) return false;
  if ((gy === 0 || gy === GRID_SIZE - 1) && gx === ENTRANCE_X) return false;
  return ![CELL_STATIC, CELL_PLAYER, CELL_SPECIAL, CELL_SINGLE].includes(grid[gy][gx]);
}

// PATHFINDING ---------------------------------------------------------------

function computePath(grid) {
  const start = { x: ENTRANCE_X, y: GRID_SIZE - 1 };
  const goal = { x: ENTRANCE_X, y: 0 };
  const raw = findPath(grid, start, goal);
  if (!raw.length) return [];
  return extendWithEntrances(raw);
}

function computePathFromCell(grid, startCell) {
  if (!startCell) return [];
  const goal = { x: ENTRANCE_X, y: 0 };
  const path = findPath(grid, { x: startCell.x, y: startCell.y }, goal);
  if (!path.length) return [];
  path.push({ x: ENTRANCE_X, y: -1 });
  return path;
}

function findPath(grid, start, goal) {
  const open = [
    {
      x: start.x,
      y: start.y,
      g: 0,
      f: heuristic(start.x, start.y, goal.x, goal.y)
    }
  ];
  const cameFrom = new Map();
  const gScore = new Map([[key(start.x, start.y), 0]]);
  const closed = new Set();

  while (open.length) {
    open.sort((a, b) => a.f - b.f);
    const current = open.shift();
    const cKey = key(current.x, current.y);
    if (closed.has(cKey)) continue;
    closed.add(cKey);

    if (current.x === goal.x && current.y === goal.y) {
      return reconstructPath(cameFrom, current);
    }

    for (const move of MOVES) {
      const nx = current.x + move.dx;
      const ny = current.y + move.dy;
      if (nx < 0 || ny < 0 || nx >= GRID_SIZE || ny >= GRID_SIZE) continue;
      if (!isWalkableCell(grid, nx, ny)) continue;
      if (move.diagonal && !canPassDiagonal(grid, current.x, current.y, move.dx, move.dy)) continue;
      const nk = key(nx, ny);
      const tentativeG = current.g + move.cost;
      if (tentativeG >= (gScore.get(nk) ?? Infinity)) continue;
      cameFrom.set(nk, cKey);
      gScore.set(nk, tentativeG);
      open.push({
        x: nx,
        y: ny,
        g: tentativeG,
        f: tentativeG + heuristic(nx, ny, goal.x, goal.y)
      });
    }
  }

  return [];
}

function reconstructPath(cameFrom, current) {
  const path = [{ x: current.x, y: current.y }];
  let keyPtr = key(current.x, current.y);
  while (cameFrom.has(keyPtr)) {
    const prevKey = cameFrom.get(keyPtr);
    const [px, py] = prevKey.split(",").map(Number);
    path.unshift({ x: px, y: py });
    keyPtr = prevKey;
  }
  return path;
}

function extendWithEntrances(path) {
  const extended = path.slice();
  extended.unshift({ x: ENTRANCE_X, y: GRID_SIZE });
  extended.push({ x: ENTRANCE_X, y: -1 });
  return extended;
}

function hasPath(grid) {
  return computePath(grid).length > 0;
}

function isWalkableCell(grid, x, y) {
  const value = grid[y][x];
  return (
    value === CELL_EMPTY ||
    value === CELL_SPEED ||
    value === CELL_SLOW ||
    value === CELL_DETOUR ||
    value === CELL_STONE ||
    value === CELL_REWIND ||
    value === CELL_SPEED_USED ||
    value === CELL_SLOW_USED ||
    value === CELL_DETOUR_USED ||
    value === CELL_STONE_USED ||
    value === CELL_REWIND_USED
  );
}

function canPassDiagonal(grid, x, y, dx, dy) {
  const horizX = x + dx;
  const vertY = y + dy;
  if (!isWalkableCell(grid, horizX, y)) return false;
  if (!isWalkableCell(grid, x, vertY)) return false;
  return true;
}

function key(x, y) {
  return `${x},${y}`;
}

function heuristic(x, y, gx, gy) {
  return Math.hypot(gx - x, gy - y);
}

function pathDistance(grid) {
  const path = computePath(grid);
  return path.length ? computeSegmentLengths(path).reduce((a, b) => a + b, 0) : 0;
}

function evaluateGridForAi(grid) {
  const info = analyzePath(grid);
  if (!info) return -Infinity;
  return info.totalDistance * AI_PATH_WEIGHT + info.padScore;
}

function computeSegmentLengths(path) {
  const lengths = [];
  for (let i = 0; i < path.length - 1; i++) {
    const start = centerOf(path[i]);
    const end = centerOf(path[i + 1]);
    lengths.push(Math.hypot(end.x - start.x, end.y - start.y));
  }
  return lengths;
}

function analyzePath(grid) {
  const path = computePath(grid);
  if (!path.length) return null;
  const lengths = computeSegmentLengths(path);
  const totalDistance = lengths.reduce((sum, len) => sum + len, 0);
  const padScore = computePadScore(grid, path);
  return { path, lengths, totalDistance, padScore };
}

function computePadScore(grid, path) {
  let score = 0;
  const visited = new Set();
  for (const node of path) {
    if (node.x < 0 || node.y < 0 || node.x >= GRID_SIZE || node.y >= GRID_SIZE) continue;
    const key = keyFor(node.x, node.y);
    if (visited.has(key)) continue;
    visited.add(key);
    const value = grid[node.y]?.[node.x];
    const padType = padTypeFromCell(value);
    if (padType && PAD_AI_SCORES[padType]) {
      score += PAD_AI_SCORES[padType];
    }
  }
  return score;
}

function keyFor(x, y) {
  return `${x},${y}`;
}

function segmentDirectionVector(path, index) {
  if (!path || index == null || index >= path.length - 1 || index < 0) return null;
  const start = centerOf(path[index]);
  const end = centerOf(path[index + 1]);
  const dx = end.x - start.x;
  const dy = end.y - start.y;
  const len = Math.hypot(dx, dy);
  if (len === 0) return null;
  return { x: dx / len, y: dy / len };
}

function segmentStep(path, index) {
  if (!path || index == null || index >= path.length - 1 || index < 0) return null;
  const start = path[index];
  const end = path[index + 1];
  return { x: Math.sign(end.x - start.x), y: Math.sign(end.y - start.y) };
}

function centerOf(node) {
  return { x: node.x + 0.5, y: node.y + 0.5 };
}

function scoreSpecialPlacement(pathInfo, specialType, cell) {
  const special = { type: specialType, placed: true, cell };
  const positions = pathInfo.path;
  switch (specialType) {
    case "radius":
      return scoreRadiusPlacement(positions, special) * SPECIAL_RADIUS_WEIGHT;
    case "row":
    case "column":
      return scoreBeamPlacement(positions, special) * SPECIAL_BEAM_WEIGHT;
    case "gravity":
      return scoreGravityPlacement(positions, special) * SPECIAL_GRAVITY_WEIGHT;
    case "lightning":
      return scoreLightningPlacement(positions, special) * SPECIAL_LIGHTNING_WEIGHT;
    default:
      return 0;
  }
}

function scoreRadiusPlacement(pathNodes, special) {
  let coverage = 0;
  pathNodes.forEach((node) => {
    if (node.x < 0 || node.x >= GRID_SIZE || node.y < 0 || node.y >= GRID_SIZE) return;
    const pos = { x: node.x + 0.5, y: node.y + 0.5 };
    if (isPointInsideSpecial(pos, special)) coverage++;
  });
  return coverage;
}

function scoreBeamPlacement(pathNodes, special) {
  let coverage = 0;
  pathNodes.forEach((node) => {
    const pos = { x: node.x + 0.5, y: node.y + 0.5 };
    if (isPointInsideSpecial(pos, special)) coverage++;
  });
  return coverage;
}

function scoreGravityPlacement(pathNodes, special) {
  let total = 0;
  const centerX = special.cell.x + 0.5;
  const centerY = special.cell.y + 0.5;
  pathNodes.forEach((node) => {
    const pos = { x: node.x + 0.5, y: node.y + 0.5 };
    const dx = pos.x - centerX;
    const dy = pos.y - centerY;
    const dist = Math.hypot(dx, dy);
    if (dist <= SPECIAL_RADIUS) {
      total += (SPECIAL_RADIUS - dist) / SPECIAL_RADIUS;
    }
  });
  return total;
}

function scoreLightningPlacement(pathNodes, special) {
  let hits = 0;
  let inside = false;
  pathNodes.forEach((node) => {
    const pos = { x: node.x + 0.5, y: node.y + 0.5 };
    const nowInside = isPointInsideSpecial(pos, special);
    if (nowInside && !inside) hits++;
    inside = nowInside;
  });
  return hits;
}

function drawPadPlate(cell, gridX, gridY, context = ctx, offsetY = GRID_OFFSET_Y) {
  const renderCtx = context;
  const type = padTypeFromCell(cell);
  if (!type) return;
  const config = PAD_VISUALS[type] || PAD_VISUALS.speed;
  const isActive = isPadActiveCell(cell);
  const color = config.color;
  let inset = config.inset ?? 10;
  let alpha = config.idleAlpha ?? 0.3;
  const baseBrightness = config.baseBrightness ?? 0.48;
  const pulseRange = config.pulseRange ?? 0.25;
  let brightness = isActive ? baseBrightness : baseBrightness * 0.85;
  if (isActive) {
    const phase = (padPulseTimer / PAD_PULSE_PERIOD) * Math.PI * 2;
    const normalized = (Math.sin(phase) + 1) / 2;
    inset = inset - normalized * 2;
    brightness = baseBrightness + normalized * pulseRange;
    const activeAlpha = config.activeAlpha ?? alpha + 0.25;
    alpha = alpha + normalized * (activeAlpha - alpha);
  } else {
    alpha *= 0.6;
  }
  const r = Math.min(255, Math.round(color.r * brightness));
  const g = Math.min(255, Math.round(color.g * brightness));
  const b = Math.min(255, Math.round(color.b * brightness));
  renderCtx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
  const x = gridX * CELL_SIZE + inset;
  const y = offsetY + gridY * CELL_SIZE + inset;
  renderCtx.fillRect(x, y, CELL_SIZE - inset * 2, CELL_SIZE - inset * 2);
  if (config.iconChar) {
    drawPadGlyph(config, gridX, gridY, color, isActive, renderCtx, offsetY);
  }
}

function drawPadGlyph(config, gridX, gridY, baseColor, isActive, context = ctx, offsetY = GRID_OFFSET_Y) {
  const renderCtx = context;
  const cx = gridX * CELL_SIZE + CELL_SIZE / 2;
  const cy = offsetY + gridY * CELL_SIZE + CELL_SIZE / 2;
  const fontSize = Math.floor(CELL_SIZE * 0.62 * (config.charScale ?? 1));
  const color = config.charColor
    ? config.charColor
    : `rgba(${Math.min(255, Math.round(baseColor.r * 0.85))}, ${Math.min(255, Math.round(baseColor.g * 0.85))}, ${Math.min(255, Math.round(
        baseColor.b * 0.85
      ))}, ${isActive ? 0.95 : 0.65})`;
  const step = CELL_SIZE * 0.05;
  const offsetX = (config.charOffset?.x ?? 0) * step;
  const offsetYChar = (config.charOffset?.y ?? 0) * step;
  renderCtx.save();
  renderCtx.font = `bold ${fontSize}px "Courier New", monospace`;
  renderCtx.textAlign = "center";
  renderCtx.textBaseline = "middle";
  renderCtx.fillStyle = color;
  renderCtx.fillText(config.iconChar, cx + offsetX, cy + offsetYChar);
  renderCtx.restore();
}

function isPadActiveCell(cell) {
  return (
    cell === CELL_SPEED ||
    cell === CELL_SLOW ||
    cell === CELL_DETOUR ||
    cell === CELL_STONE ||
    cell === CELL_REWIND
  );
}

function isPadUsedCell(cell) {
  return (
    cell === CELL_SPEED_USED ||
    cell === CELL_SLOW_USED ||
    cell === CELL_DETOUR_USED ||
    cell === CELL_STONE_USED ||
    cell === CELL_REWIND_USED
  );
}

function isPadCell(cell) {
  return isPadActiveCell(cell) || isPadUsedCell(cell);
}

function padTypeFromCell(cell) {
  switch (cell) {
    case CELL_SPEED:
    case CELL_SPEED_USED:
      return "speed";
    case CELL_SLOW:
    case CELL_SLOW_USED:
      return "slow";
    case CELL_DETOUR:
    case CELL_DETOUR_USED:
      return "detour";
    case CELL_STONE:
    case CELL_STONE_USED:
      return "stone";
    case CELL_REWIND:
    case CELL_REWIND_USED:
      return "rewind";
    default:
      return null;
  }
}

function padUsedVariant(cell) {
  switch (cell) {
    case CELL_SPEED:
      return CELL_SPEED_USED;
    case CELL_SLOW:
      return CELL_SLOW_USED;
    case CELL_DETOUR:
      return CELL_DETOUR_USED;
    case CELL_STONE:
      return CELL_STONE_USED;
    case CELL_REWIND:
      return CELL_REWIND_USED;
    default:
      return cell;
  }
}

function findNeutralSpecial(list, x, y) {
  if (!list) return null;
  return list.find((special) => special?.cell && special.cell.x === x && special.cell.y === y) || null;
}

function drawStaticBlockSprite(gridX, gridY, context = ctx, offsetY = GRID_OFFSET_Y) {
  const baseX = gridX * CELL_SIZE;
  const baseY = offsetY + gridY * CELL_SIZE;
  context.save();
  drawBeveledTile(
    baseX,
    baseY,
    {
      outer: "#163821",
      inner: "#2e623d",
      border: "#04160a",
      highlight: "rgba(185,255,185,0.1)"
    },
    context
  );
  context.restore();
}

function drawPlayerBlockSprite(gridX, gridY, context = ctx, offsetY = GRID_OFFSET_Y) {
  const baseX = gridX * CELL_SIZE;
  const baseY = offsetY + gridY * CELL_SIZE;
  context.save();
  drawBeveledTile(
    baseX,
    baseY,
    {
      outer: "#1d6f2c",
      inner: "#2fb64d",
      border: "#0f2f11",
      highlight: "rgba(255,255,255,0.12)"
    },
    context
  );
  context.restore();
}

function drawSingleBlockSprite(gridX, gridY, context = ctx, offsetY = GRID_OFFSET_Y) {
  const baseX = gridX * CELL_SIZE;
  const baseY = offsetY + gridY * CELL_SIZE;
  context.save();
  drawBeveledTile(
    baseX,
    baseY,
    {
      outer: "#4b4b4b",
      inner: "#7d7d7d",
      border: "#111",
      highlight: "rgba(255,255,255,0.08)"
    },
    context
  );
  context.restore();
}

function drawSpecialBlockSprite(gridX, gridY, paletteOverride, context = ctx, offsetY = GRID_OFFSET_Y) {
  const baseX = gridX * CELL_SIZE;
  const baseY = offsetY + gridY * CELL_SIZE;
  const palette =
    paletteOverride || {
      outer: "#f3cf63",
      inner: "#ffeaa2",
      border: "#3b2f10",
      highlight: "rgba(255,255,255,0.2)",
      arrow: null,
      glyph: "?"
    };
  const { arrow, ...tilePalette } = palette;
  context.save();
  drawBeveledTile(baseX, baseY, tilePalette, context);
  if (arrow) {
    drawBlockLine(baseX, baseY, arrow, context);
  }
  if (palette.glyph) {
    drawSpecialGlyph(baseX, baseY, palette, context);
  }
  context.restore();
}

function drawBlockLine(baseX, baseY, direction, context = ctx) {
  context.save();
  context.fillStyle = "rgba(70, 30, 110, 0.85)";
  const inset = 8;
  const thickness = 4;
  if (direction === "horizontal") {
    const midY = baseY + CELL_SIZE / 2 - thickness / 2;
    context.fillRect(baseX + inset, midY, CELL_SIZE - inset * 2, thickness);
  } else {
    const midX = baseX + CELL_SIZE / 2 - thickness / 2;
    context.fillRect(midX, baseY + inset, thickness, CELL_SIZE - inset * 2);
  }
  context.restore();
}

function drawSpecialGlyph(baseX, baseY, palette, context = ctx) {
  const glyph = palette.glyph;
  if (!glyph) return;
  const color = palette.glyphColor || palette.border || "#fff";
  const scale = palette.glyphScale ?? 1;
  const step = CELL_SIZE * 0.05;
  const offsetX = (palette.glyphOffset?.x ?? 0) * step + (palette.glyphOffsetPx?.x ?? 0);
  const offsetY = (palette.glyphOffset?.y ?? 0) * step + (palette.glyphOffsetPx?.y ?? 0);
  context.save();
  const fontSize = Math.floor(CELL_SIZE * 0.55 * scale);
  context.font = `bold ${fontSize}px "Courier New", monospace`;
  context.fillStyle = color;
  context.textAlign = "center";
  context.textBaseline = "middle";
  context.fillText(glyph, baseX + CELL_SIZE / 2 + offsetX, baseY + CELL_SIZE / 2 + offsetY);
  context.restore();
}

function drawSnowflake(cx, cy, radius) {
  ctx.save();
  ctx.strokeStyle = "rgba(190, 230, 255, 0.14)";
  ctx.lineWidth = 1.3;
  const arms = 6;
  for (let i = 0; i < arms; i++) {
    const angle = (Math.PI * 2 * i) / arms;
    const x = cx + Math.cos(angle) * radius;
    const y = cy + Math.sin(angle) * radius;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(x, y);
    ctx.stroke();
    const branchAngle1 = angle + Math.PI / 6;
    const branchAngle2 = angle - Math.PI / 6;
    const branchLen = radius * 0.35;
    const bx1 = x - Math.cos(angle) * branchLen + Math.cos(branchAngle1) * branchLen;
    const by1 = y - Math.sin(angle) * branchLen + Math.sin(branchAngle1) * branchLen;
    const bx2 = x - Math.cos(angle) * branchLen + Math.cos(branchAngle2) * branchLen;
    const by2 = y - Math.sin(angle) * branchLen + Math.sin(branchAngle2) * branchLen;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(bx1, by1);
    ctx.moveTo(x, y);
    ctx.lineTo(bx2, by2);
    ctx.stroke();
  }
  ctx.restore();
}

function drawIcyArrows(cx, cy, radius) {
  const outer = "rgba(130, 195, 255, 0.14)";
  const inner = "rgba(150, 210, 255, 0.14)";
  drawRadialArrows(cx, cy, radius * 0.95, radius * 0.35, 6, 0, outer);
  drawRadialArrows(cx, cy, radius * 0.65, radius * 0.25, 6, Math.PI / 6, inner);
}

function drawRadialArrows(cx, cy, outerLen, innerLen, count, offset, color) {
  ctx.save();
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = 1.4;
  for (let i = 0; i < count; i++) {
    const angle = offset + (Math.PI * 2 * i) / count;
    const innerX = cx + Math.cos(angle) * innerLen;
    const innerY = cy + Math.sin(angle) * innerLen;
    const outerX = cx + Math.cos(angle) * outerLen;
    const outerY = cy + Math.sin(angle) * outerLen;
    ctx.beginPath();
    ctx.moveTo(innerX, innerY);
    ctx.lineTo(outerX, outerY);
    ctx.stroke();
    const headAngle1 = angle + Math.PI / 6;
    const headAngle2 = angle - Math.PI / 6;
    const headSize = 6;
    ctx.beginPath();
    ctx.moveTo(outerX, outerY);
    ctx.lineTo(outerX - Math.cos(headAngle1) * headSize, outerY - Math.sin(headAngle1) * headSize);
    ctx.lineTo(outerX - Math.cos(headAngle2) * headSize, outerY - Math.sin(headAngle2) * headSize);
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
}

function drawLightningBolts(cx, cy, radius, ratio, flashing) {
  const bolts = 6;
  ctx.save();
  for (let i = 0; i < bolts; i++) {
    const angle = (Math.PI * 2 * i) / bolts + (ratio * Math.PI) / 3;
    const length = radius * (0.6 + 0.2 * Math.random());
    const points = [];
    const segments = 4;
    for (let s = 0; s <= segments; s++) {
      const t = s / segments;
      const r = length * t;
      const wobble = (Math.random() - 0.5) * radius * 0.15 * (1 - t);
      const px = cx + Math.cos(angle) * r + Math.cos(angle + Math.PI / 2) * wobble;
      const py = cy + Math.sin(angle) * r + Math.sin(angle + Math.PI / 2) * wobble;
      points.push({ x: px, y: py });
    }
    ctx.strokeStyle = flashing ? "rgba(255,255,255,0.45)" : "rgba(255,215,130,0.5)";
    ctx.lineWidth = flashing ? 2.5 : 1.6;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    points.forEach((p) => ctx.lineTo(p.x, p.y));
    ctx.stroke();
  }
  ctx.restore();
}

function drawElectricStun(cx, cy, radius, intensity) {
  ctx.save();
  const sparks = 12;
  for (let i = 0; i < sparks; i++) {
    const angle = (Math.PI * 2 * i) / sparks;
    const len = radius * (0.6 + 0.3 * Math.random());
    const wobble = (Math.random() - 0.5) * radius * 0.2;
    const color = `rgba(255, 255, 255, ${0.25 + 0.2 * intensity})`;
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.4;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(angle) * len + Math.cos(angle + Math.PI / 2) * wobble, cy + Math.sin(angle) * len + Math.sin(angle + Math.PI / 2) * wobble);
    ctx.stroke();
  }
  ctx.restore();
}

function drawBeveledTile(baseX, baseY, palette, context = ctx) {
  const bevel = Math.max(3, Math.floor(CELL_SIZE * 0.18));
  const innerInset = 4;
  context.beginPath();
  context.moveTo(baseX + bevel, baseY);
  context.lineTo(baseX + CELL_SIZE - bevel, baseY);
  context.lineTo(baseX + CELL_SIZE, baseY + bevel);
  context.lineTo(baseX + CELL_SIZE, baseY + CELL_SIZE - bevel);
  context.lineTo(baseX + CELL_SIZE - bevel, baseY + CELL_SIZE);
  context.lineTo(baseX + bevel, baseY + CELL_SIZE);
  context.lineTo(baseX, baseY + CELL_SIZE - bevel);
  context.lineTo(baseX, baseY + bevel);
  context.closePath();

  context.fillStyle = palette.outer;
  context.fill();
  context.lineWidth = 2;
  context.strokeStyle = palette.border || "#050505";
  context.stroke();

  context.beginPath();
  context.moveTo(baseX + bevel + innerInset, baseY + innerInset);
  context.lineTo(baseX + CELL_SIZE - bevel - innerInset, baseY + innerInset);
  context.lineTo(baseX + CELL_SIZE - innerInset, baseY + bevel + innerInset);
  context.lineTo(baseX + CELL_SIZE - innerInset, baseY + CELL_SIZE - bevel - innerInset);
  context.lineTo(baseX + CELL_SIZE - bevel - innerInset, baseY + CELL_SIZE - innerInset);
  context.lineTo(baseX + bevel + innerInset, baseY + CELL_SIZE - innerInset);
  context.lineTo(baseX + innerInset, baseY + CELL_SIZE - bevel - innerInset);
  context.lineTo(baseX + innerInset, baseY + bevel + innerInset);
  context.closePath();
  context.fillStyle = palette.inner || "#3a3a3a";
  context.fill();

  context.strokeStyle = palette.highlight || "rgba(255,255,255,0.1)";
  context.lineWidth = 1;
  context.setLineDash([2, 3]);
  context.stroke();
}

// SPECIALS -----------------------------------------------------------------

function createSpecialTemplate(type = pickSpecialType(state.rng)) {
  return {
    type,
    cell: null,
    placed: false,
    effectTimer: 0,
    cooldown: 0,
    flashTimer: 0
  };
}

function createNeutralSpecial(type, cell) {
  return {
    type,
    cell: { ...cell },
    placed: true,
    effectTimer: 0,
    cooldown: 0,
    flashTimer: 0,
    neutral: true
  };
}

function cloneSpecial(special) {
  if (!special) return null;
  return {
    type: special.type,
    cell: special.cell ? { ...special.cell } : null,
    placed: special.placed,
    effectTimer: 0,
    cooldown: special.cooldown || 0,
    flashTimer: 0,
    neutral: !!special.neutral
  };
}

function cloneNeutralSpecials(list) {
  if (!list) return [];
  return list.map((special) => cloneSpecial(special));
}

function pickSpecialType(rng) {
  const roll = rng();
  if (roll < 0.25) return "radius";
  if (roll < 0.5) return "lightning";
  if (roll < 0.75) return "gravity";
  if (roll < 0.875) return "row";
  return "column";
}

function isPointInsideSpecial(pos, special) {
  if (!special?.placed || !special.cell) return false;
  const { x, y } = special.cell;
  if (special.type === "radius" || special.type === "gravity" || special.type === "lightning") {
    const dx = pos.x - (x + 0.5);
    const dy = pos.y - (y + 0.5);
    return Math.hypot(dx, dy) <= SPECIAL_RADIUS;
  }
  if (special.type === "row") {
    return pos.y >= y && pos.y <= y + 1;
  }
  if (special.type === "column") {
    return pos.x >= x && pos.x <= x + 1;
  }
  return false;
}

// RANDOM HELPERS -----------------------------------------------------------

function randomInt(rng, min, max) {
  return Math.floor(rng() * (max - min + 1)) + min;
}

function shuffleWithRng(arr, rng) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function hashSeed(str) {
  let h = 1779033703 ^ str.length;
  for (let i = 0; i < str.length; i++) {
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return h >>> 0;
}

function mulberry32(a) {
  return function () {
    let t = (a += 0x6d2b79f5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function applyAlpha(color, alpha) {
  if (!color) {
    return `rgba(255, 120, 120, ${alpha})`;
  }
  if (!color.startsWith("#")) {
    return color;
  }
  const rgb = hexToRgb(color);
  return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
}

function hexToRgb(hex) {
  const normalized = hex.replace("#", "");
  const bigint = parseInt(normalized, 16);
  return {
    r: (bigint >> 16) & 255,
    g: (bigint >> 8) & 255,
    b: bigint & 255
  };
}

function decayGravityOffset(offset, delta) {
  if (!offset) return null;
  const decay = Math.pow(0.5, delta / 2); // ~2s half-life
  const next = { x: offset.x * decay, y: offset.y * decay };
  if (Math.abs(next.x) < 0.001 && Math.abs(next.y) < 0.001) {
    return null;
  }
  return next;
}
